

==书本课后题==

## 硬件

1. 多级流水线(Pipeline)能够加速指令执行速度，但条件跳转指令会严重影响多级流水线的效率。请解释其原因。
    3级以上的流水线 仍保持3步的指令执行分解，但多级流水线很容易受跳转指令影响：当执行到跳转指令时，流水线上已经预取的和预译码的指令必须先清空并根据跳转指令的执行结果重新取指和译码。同时多级流水线需要更多的触发器单元从而增加CPU的动态功耗、CPU晶元的面积和封装体积。

2. 对比RISC和CISC的区别。
    - CISC (Complex Instruction Set Computer)，复杂指令集计算机支持丰富的存储器和I/O的寻址操作，使用单一指令即可对特定存储器和I/O进行读和改写操作。此类CPU的指令集较为庞大。
    - RISC (Reduced Instruction-Set Computer)，精简指令集计算机也称“Load-Store结构”计算机，除了“load”(存储器到寄存器)和“store”(寄存器到存储器)操作外，其他指令仅对寄存器操作。由于存储器的操作模式比较简单，指令集相对较小。

    - CPU (Central Processing Unit)，能够执行特定指令(集)并实现数值和逻辑等运算的功能单元。CPU带有并行总线与存储器和I/O连接，能够从(可执行的)存储器取指令(Fetch)、译码(Decode)、执行指令(Excute)，并将执行结果保存到存储器。
    - CPU内核 (Core)，由CPU、中断控制器、调试单元和总线等组成的核心单元。
    - SoC (System on Chip)，(芯)片上系统的缩写，由CPU内核、片上存储器(含ROM和RAM)、片上外设(如时钟系统、定时器、UART等)组成，只需要外部电源、振荡器或大容量存储器即可工作。
    - MCU (Micro-Controller Unit)，微控制器单元，由CPU内核、片上存储器(含ROM和RAM)、片上外设(如时钟系统、定时器、UART等)组成，只需要外部电源和振荡器即可工作。
    - 指令集，每一种体系架构的CPU对应一组特定的指令(称作指令集)，根据指令的执行结果可以将指令集分为数据传送、堆栈操作、数值计算、逻辑运算、程序跳转等几大类。

3. 对比CPU、MPU、MCU和SoC四类半导体器件的区别。
    1. CPU(Central Processing Unit)，是一台计算机的运算核心和控制核心。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。差不多所有的CPU的运作原理可分为四个阶段：提取(Fetch)、解码(Decode)、执行(Execute)和写回(Writeback)。 CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。

    2. MPU (Micro Processor Unit)，叫微处理器(不是微控制器)，通常代表一个功能强大的CPU(暂且理解为增强版的CPU吧),但不是为任何已有的特定计算目的而设计的芯片。这种芯片往往是个人计算机和高端工作站的核心CPU。Intel X86，ARM的一些Cortex-A芯片如飞思卡尔i.MX6、全志A20、TI AM335X等都属于MPU。

    3. MCU(Micro Control Unit)，叫微控制器，是指随着大规模集成电路的出现及其发展，将计算机的CPU、RAM、ROM、定时计数器和多种I/O接口集成在一片芯片上，形成芯片级的芯片，比如51，AVR、Cortex-M这些芯片，内部除了CPU外还有RAM、ROM，可以直接加简单的外围器件(电阻，电容)就可以运行代码了。而如x86、ARM这些MPU就不能直接放代码了，它只不过是增强版的CPU，所以得添加RAM，ROM。

    4. SOC(System on Chip)，指的是片上系统，MCU只是芯片级的芯片，而SOC是系统级的芯片，它既MCU(51，avr)那样有内置RAM、ROM同时又像MPU那样强大，不单单是放简单的代码，可以放系统级的代码，也就是说可以运行操作系统(将就认为是MCU集成化与MPU强处理力各优点二合一)。
4. ARM Cortex-M微内核使用哪些类型的接口总线？分别于哪些类型的片上资源连接？

    高速CPU和低速外设之间的矛盾如何解决呢？半导体技术工程师使用总线桥技术很好地解决这一问题：CPU和存储器之间不仅采用高速总线还 增加Cache(高速缓存)单元，CPU与低速外设之间采用总线桥和低速外设总线，这样的总线桥隔离技术不仅能够保持CPU拥有高速时钟，并保持低速外设的低成本。

    内部总线系统(AHB、APB和总线桥等)


5. RISC-V并不是惟一开源的ISA(指令集架构)，还有哪些？为什么RISC-V ISA最受人们欢迎？

    开源指令集、开源实现(半导体设计)、开源⼯具链 

    RISC-V ISA并不是惟一的开源ISA，为什么RISC-V备受欢迎呢？
    我们需要了解RIAC-V ISA的指令集及其特点才能确定其原因。RISC-V ISA也有多个版本， 其中RV32I和RV64I分别32位和64位的RISC-V基础整数指令集，其他都属于可选择的扩展型指令集，如RV32E是面向嵌入式系统应用的扩展类型，RV32E仅有 16个寄存器而RV32I有32个寄存器(寄存器个数越少则CPU内核的实现成本越低)。
    
    RISC-V的开放性和可扩展性(且具有标准的扩展方式)是其核心竞争力之一。 通过预留的拓展方法保持RISC-V的性价比不断地提升以满足未来应用场景，已有自定义扩展指令的RISC-V微处理器可满足当下的深度学习和增强现实等应用。

6. 以ARM Cortex-M3/M4微内核的MCU为例，说明MCU的低功耗模式的节能原理，以及片上电源和时钟树对低功耗模式的意义。
    当我们让嵌入式系统CPU进入睡眠或深睡眠的低功耗模式之前必须控制负载开关切断系统外设的电源才能达到降低系统功耗之目的，如果外设的供电电压是多种类型(如1.8V、 2.75V、3.3V、5V等都是常用的外设工作电压)则必须使用多路负载开关来分别控制每一个外设的电压开关。这样的供电电源设计称作多电源域，各个电源域的工作电压和功率不同， 而且有独立的负载开关控制。这种电源域设计也常用于MCU芯片内部，用于控制片上外设电源开关。MCU片内的电源拓扑如图2.28所示。

    ==多电源域==降低高速CPU动态功耗的有效方法之一是，降低CPU核工作电压，譬如STM32F401的CPU核仅有1.2V，由于CPU核与片上存储器之间的连接信号密度较大(如32位地址总线和 32位数据总线)，必须降低片上存储器的工作电压以简化接口。然而片上外设，尤其使用I/O引脚的片上外设则与外部供电电源电压保持一致。当CPU进入(轻)睡眠模式时， CPU将停止工作，但必须使用状态维持的电源控制(State retention power gating)技术确保CPU内部寄存器内容维持不变，片上振荡器、存储器和外设仍继续工作， 被中断唤醒后将立即继续工作。当CPU进入深睡眠模式时，不仅CPU完全掉电工作，振荡器和片上外设全部停止工作，仅片上SRAM数据仍保留，被外部中断或复位唤醒后将 花费更长时间重新开始工作。很显然，(轻)睡眠的功耗远大于深睡眠。

    除了片上内建的多路DC-DC输出分别为CPU内核、时钟发生器单元、片上存储器、片上外设等功能单元独立供电外，还可以根据CPU的低功耗模式切断这个单元的供电和状态维持 电源，而且每一个功能单元的时钟频率也是可编程和独立控制的。MCU片上的多电源域和多时钟域设计，实现各域独立供电电源和维持电源及其开关控制，以及各域独立的 可编程时钟频率和开关控制都是为了优化性能域功耗之比达到最大。

7. 查阅STM32F401和GD32VF103两种MCU的Datasheet，从CPU内核时钟速度、FlashROM、RAM和外设，以及存储器映射、片内电源和时钟单元等几个方面对比他们。
    。。。

3. 指令集和工具链（含编译器和链接器）之间存在什么关系？据此简要说明RISC-V体系才是真正的开源CPU内核 

    RISC-V提供了特权级指令和用户级指令，同时提供了详细的RISC-V特权级指令规范和 RISC-V用户级指令规范的详细信息。 

    对于设计CPU来说，工具链是软件开发人员和cpu交互的窗口，没有工具链，对软件开发人 员开发软件要求很高，甚至软件开发者无法让cpu工作起来。在cpu设计中，工具链的开发 是一个需要巨大工作量的工作。如果用RISC-V来设计芯片，芯片设计公司不再担心工具链 问题，只需专注于芯片设计，RISC-V社区已经提供了完整的工具链，并且RISC-V基金会持 续维护该工具链。 

    RISC-V实现了开源指令集、开源实现(半导体设计)、开源⼯具链，所以RISC-V体系才是真正的开源CPU内核RISC-V体系才是真正的开源CPU内核  

## 系统软件及编程语言

1. C++和Python都属于⾯向对象编程(Object Oriented Programming)语⾔。请查阅资料了解OOP 具有哪些特征？请逐⼀举例且简要说明每⼀个特征  

    ①封装性：封装是指将一个计算机系统中的数据以及与这个数据相关的一切操作语言（即描述每一个对象 的属性以及其行为的程序代码）组装到一起，一并封装在一个有机的实体中，把它们封装在一个“模块” 中，使得软件结构的相关部件的实现“高内聚、低耦合”的“最佳状态”便是面向对象技术的封装性所需 要实现的最基本的目标。对于用户来说，对象是如何对各种行为进行操作、运行、实现等细节是不需要刨 根问底了解清楚的，用户只需要通过封装外的通道对计算机进行相关方面的操作即可。大大地简化了操作 的步骤，使用户使用起计算机来更加高效、更加得心应手。  

    ②继承性：其主要指的是两种或者两种以上的类之间的联系与区别。继承，顾名思义，是后者延续前者的 某些方面的特点，而在面向对象技术则是指一个对象针对于另一个对象的某些独有的特点、能力进行复制 或者延续。分为单继承与多继承，如果从继承中包含的内容进行划分，则继承可以分为四类，分别为取代 继承、包含继承、受限继承、特化继承。  

    ③多态性：从宏观的角度来讲，多态性是指在面向对象技术中，当不同的多个对象同时接收到同一个完全 相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态性是指在一 组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用，即便这若干个具 有相同函数名的函数所表示的函数是不同的。  

2. 按照Arduino开源社区惯例，每⼀个开发板的MCU的I/O引脚映射成⼀组序数。BlueFi开源板的引 脚定义“../packages/adafruit/hardware/nrf52/0.20.5/variants/bluefi/”⽂件中。这种处理⽅法的 ⽬的之⼀是提⾼Arduino程序源码的可移植性，请说明原因  

    其一是软件开发者不必直接访问半导体厂商提供的驱动库，；其二是提高Arduino软件的可移植性。节省开发时间，“variant.cpp”文件就是将原始的I/O引脚编号映射为0～46这样的序数所有Arduino开源 板都有一个可编程的LED指示灯， 并称之为“内建的LED”。所以下⾯的示例程序可被任⼀Arduino板 执⾏：  
    void setup() {  
    pinMode(BUILTIN_LED, OUTPUT);  
    }  
    void loop() {  
    digitalWrite(BUILTIN_LED, HIGH);  
    delay(500);  
    digitalWrite(BUILTIN_LED, LOW);  
    delay(500);  
    }   

1. ECS的实时性指的是什么?为什么说计算机使用Linux、Windows等OS属于非实时的? 

    实时操作系统意味着，某个事件发生所触发的任务必须在预定时间内完成(不是最快完 成，而是在预定的截止时间之前完成)。 

    一个实时操作系统面对变化的负载（从最小到最坏的情况）时必须确定性地保证满足时间要 求。请注意，必须要满足确定性，而不是要求速度足够快！例如，如果使用足够强大的CPU， Windows在CPU空闲时可以提供非常短的典型中断响应，但是，当某些后台任务正在运 行时，有时候响应会变得非常漫长，以至于某一个简单的读取文件的任务会长时间无响应， 甚至直接挂死。这是一个基本的问题：并不是Windows不够快或效率不够高，而是因为它 不能提供确定性，所以，Windows不是一个实时操作系统。 

2. 假设某时间片轮转型RTOS的ECS软件包含3个任务，简述任务调度器的工作过程。 

    任务调度器能够并行处理多任务的机制是，将CPU的时间分割为多个时间片并分配给已经 创建的3个任务，每个任务占用CPU的一个时间片，当正在执行的任务的时间片消耗完毕 时，调度器实施任务切换(即将正在执行的任务挂起，继续执行下一个任务)，每一个任务按 分配的时间片占用CPU一定时间后被挂起，如此无穷地循环，让我们感觉多个任务被并行执行。 

3. 假设某抢占型RTOS的ECS软件包含3个任务，简述任务调度器的工作过程。 

    抢占型RTOS的任务调度器相对复杂，每个任务不仅有自己的时间片，还有自己的优先级，正在执行的低优先级任务的时间片可能会被高优先级的任务抢占。抢占型RTOS将CPU的时间分割为多个时间片并分配给已经创建的3个任务，每个任务占 用CPU的一个时间片，优先执行高优先级任务，当正在执行的任务的时间片消耗完毕时，调度器实施任务切换(优先执行高优先级任务)，每一个任务按分配的时间片占用CPU一定 时间后被挂起，如此无穷地循环，让我们感觉多个任务被并行执行。   

4. ECS软件使用RTOS的优点和缺点分别有哪些? 

    优点：支持任务驱动和多任务的软件设计方法能够将复杂的嵌入式 系统软件分割成多个易 于实现的简单任务软件，不仅易维护还能确保实时性。 

    缺点：任何RTOS都需要额外占用嵌入式系统有限的ROM空间和RAM空间。 

    - 其一是，RTOS种类繁多且无统一的标准 API，甚至对开发环境和软件工具也有特殊要求(没 有统一的开发环境); 
    - 其二是，昂贵的商用RTOS 授权费，虽然也有很多种免费的甚至开源 的RTOS可以选择，但是没有技术支持也可能会增加软件 开发时间和技术成本;
    - 其三是，RTOS的Bug， 虽然所有RTOS研发者都认为自己已经尽力做到最好，但复杂的RTOS内 核软件和相关中间件本身就是庞大的软件系统，有Bug是在所难免的。 

5. 某ECS系统包含4个按钮输入、4个模拟输入、1个图形显示器输出、1个通讯接口（可接收指令和数据，可发送应答数据)等资源，所有输入均支持中断模式，请使用中断与查询 
   相结合的编程范例绘制流程图实现以下功能： 

    1）周期地执行模拟转换、保存和显示； 

    2）按钮可设置模拟转换周期； 

    3）当通讯接口收到新命令时，将当前的模拟转换结果发送出去。  

    ![PPT课后题2021-09-19-16-42-42](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-42-42.png)



## 输入输出

1. 动手验证本章的所有示例程序。
    ```cpp
    #include <Arduino.h>
    class LED {
    public:
        LED(uint8_t pin);
        uint8_t getAttachPin(void);
        void on(void);
        void off(void);
        void toggle(void);
        bool state(void);
    
    private:
        bool __isInited;
        bool __state;
        uint8_t __pin;
    };
    LED::LED(uint8_t pin) {
    __isInited = 1;
    __state = 0;
    __pin = pin;
    pinMode(__pin, OUTPUT);
    digitalWrite(__pin, __state);
    }
    
    uint8_t LED::getAttachPin(void) {
        return __pin;
    }
    
    void LED::on(void) {
        __state = 1;
        digitalWrite(__pin, __state);
    }
    
    void LED::off(void) {
        __state = 0;
        digitalWrite(__pin, __state);
    }
    
    void LED::toggle(void) {
        __state = (__state)?0:1;
        digitalWrite(__pin, __state);
    }
    
    bool LED::state(void) {
    return __state;
    }
    
    
    //应用
    
    void setup() {
    bluefi.begin();
    bluefi.whiteLED.off();
    }
    
    void loop() {
    bluefi.redLED.on();
    delay(100);
    bluefi.redLED.off();
    delay(900);
    }



    #include <BlueFi.h>
    void a_changed_cb(Button2& btn) {
    Serial.println(" A-Button be changed");
    }
    void b_pressed_cb(Button2& btn) {
    Serial.println(" B-Button be pressed");
    }
    void b_click_cb(Button2& btn) {
    Serial.println(" B-Button is click");
    }
    void b_2click_cb(Button2& btn) {
    Serial.println(" B-Button is double-click");
    }
    
    void setup() {
    Serial.begin(115200);
    bluefi.begin();
    bluefi.redLED.on();
    bluefi.whiteLED.off();
    bluefi.aButton.setChangedHandler(a_changed_cb);
    bluefi.bButton.setPressedHandler(b_pressed_cb);
    bluefi.bButton.setClickHandler(b_click_cb);
    bluefi.bButton.setDoubleClickHandler(b_2click_cb);
    }
    
    void loop() {
    bluefi.aButton.loop(); // update the state of A-button
    bluefi.bButton.loop(); // update the state of B-button
    if ( bluefi.aButton.isPressed() ) {
        bluefi.redLED.off();
        } else {
        bluefi.redLED.on();
        }
    }
    
    ```

2. 请尽可能多地分别列举出数字I/O、模拟I/O和脉冲调制I/O接口的应用实例。

    模拟输入： uint16_t adc_chx_value = ananlogRead(chx)
    模拟输出： analogWrite(chx, value)

3. 请从存储器映射和存储器访问的角度说明数字输出接口的状态保持机制。

    当我们将A按钮的状态保存到一个布尔型变量时，如果不采用DMA(直接存储器访问)方式，nRF52840的CPU的工作过程为：将P1.IN寄存器(即0x5000 0810地址单元)读入CPU内部某个寄存器， 然后再将D7位的值(即P1.7引脚的状态)保存到布尔型变量(即“Bit_Band”区的某个地址单元)。



4. 以按钮为例，分别设计按下时低电平有效和高电平有效的接口电路，简要说明工作原理。

    ![2021-10-31-22-35-17](https://image.wxydejoy.top/image/课后题/2021-10-31-22-35-17.png)

5. 根据PWM信号发生器的原理结构说明调整PWM信号频率的方法。

    PWM信号发生器由时钟预分频器(Prescaler)、波计数器(Wave Cpunter)或通用计数器(General Counter)、数值比较器(Comparator)等组成。

    设置时钟预分频器寄存器的值可调整PWM信号的频率，向占空比寄存器写入不同值可调整PWM信号的占空比，计数器的模式包括递增、递减、先递增-再递减等三种， 计数器的模式选择可以改变PWM信号的对齐方式(前沿对齐、后沿对齐、中心对齐)，如图4.12所示。

    PWM信号的频率受PWM模块的时钟频率、分频器和计数器的范围等三个参数约束。譬如，nRF52840的PWM模块时钟频率为16MHz，分频器可选择1/2/4/8/16/32/64/128-分频， 计数器的范围3～32767(即可设置最大的二进制位宽度是15)。如果选择1分频，即16MHz时钟为计数器工作时钟(即时钟周期为62.5ns)，使用8位的计数器分辨率时的PWM信号周期为16微秒(=256*62.5ns)，12位时的PWM信号周期为256微秒，15位时的PWM信号周期为2.048ms。

6. 除了定时器、PWM信号发生器之外，还有哪些方法能够产生调频波？
7. C/C++类封装时的构造函数和析构函数各自有什么作用？
    构造函数是对象创建完成后第一个被对象自动调用的函数。起初始化值的作用  
    析构函数作用和构造函数正好相反，是对象被销毁之前最后一个被对象自动调用的函数。用 于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间。  
8. Python语言的“import”是一种非常重要的模块化编程机制，请简要说明其用法。
9. 嵌入式系统的模拟输入通道的PGA(可编程增益放大器)具有什么作用？举例说明。
    工作原理  

    可编程增益放大器含全平衡差动放大器模块、译码器模块和电阻开关阵列模块，全平衡差动 放大器模块中的负反馈电阻分压器的电阻比确定该放大器的最大增益，通过译码器模块的译 码结果控制电阻开关阵列模块衰减输入信号的衰减量，最终实现该放大器的增益的可编程。 

    益处  

    虽然ADC等数字化器件的输入量程范围是固定的，通过调整PGA的增益可以把不同量程范 围的V(t)信号调整到[Vref-, Vref+]范围。所以通过PGA可以满足更宽量程范围的模拟信 号，不仅如此使用多路模拟信号选择器和PGA可以让多个模拟输入信号共用一个ADC等数字化器件，这种模拟前端有利于降低成本。  

10. 多个模拟输入信号可以通过MUX(多路信号选择器)和PGA等共享单个ADC组成多路模拟信号输入接口，单个DAC器件能使用MUX等实现多路模拟信号输出吗？为什么？
    不可以

    在实际应用中，DAC器件并不能保持理论上的零阶保持器的特性，当输出电压信号变化期间还会叠加噪声信号，因此DAC输出的连续信号需要经过后端处理。 每一个模拟信号输出通道必须占用一个DAC器件，无法像模拟前端那样使用多路模拟开关让多路模拟信号共用一个ADC器件。

11. 一个16位递增的定时器单元，其输入时钟信号频率为64MHz，且具有一个16位分频器，请问该定时可产生的最短定时周期和最长的定时周期分别位多少？
    已知递减的定时器模块的输入时钟频率F_in_clk，以及待产生的方波频率F_out，使用自动重装寄存器R_autoload和中断服务，程序伪码：
    ```cpp
    void iniTimer(F_out) {
    T_overflow = 1000000UL/(2*F_out); // 计算定时器的溢出周期(us)
    F_clk = F_in_clk/dv;  // 确定分频数dv和定时器时钟频率
    T_clk = 1000000UL/F_clk; // 计算定时器时钟周期
    setDividerRegister(dv); // 设置分频器寄存器的分频数为dv
    R_autoload = T_overflow/T_clk; // 定时器溢出周期比定时器时钟周期的倍数
    setAutoloadRegister(R_autoload); // 设置重装寄存器的值
    setValueRegister(R_autoload); // 设置定时器的值寄存器
    enableTimerIRQ(); // 打开定时器溢出中断
    startTimer(); // 启动定时器
    }
    
    void Timer_Handler(void) {
    clearTimerIRQ(); // 清除中断请求标志
    digitalWrite( Pin_out, !digitalRead(Pin_out) ); // 将脉冲输出引脚状态反转
    }
    ```
    使用普通定时器产生指定频率方波信号的关键是计算定时器的重装值，这个参数应是定时器时钟周期的整数倍，因此合适的分频器配置十分重要。定时器的初始化操作涉及的计算包括， 计算定时器溢出周期，配置分频器并计算定时器时钟周期，根据两者比值计算定时器重装值。为更好理解这些计算过程。

12. 某超声波测距传感器量程为10米，且具有两个I/O接口：触发测量的输入信号“trig”，脉宽调制输出信号“echo”。该传感器的工作过程：当“trig”信号出现一个不小于10us的高电平脉冲，传感器将该信号上升沿后的10us发射超声波并在“echo”引脚输出高电平，当接收到反射波时“echo”引脚立即输出低电平。请使用两个可编程I/O引脚设计硬件接口，并编程实现此类传感器的软件接口。


1. 查阅C++抽象类和接口的“多态”概念，并简述多态的优缺点。  

    如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。设计抽象类（通常称为  ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化 对象，它只能作为接口使用。  
    多态是指同样的消息被不同类型的对象接受时导致不同的行为。所谓消息是指对类的成员函 数的调用，不同的行为是指不同的实现，也就调用不同的函数。换言之，多态指的就是用同 样的接口访问功能不同的函数，从而实现“一个接口，多种方法”。  
    
    多态的优点：  代码组织结构清晰  可读性强  利于前期和后期的扩展以及维护  对拓展开放，对修改关闭  
    弊端：前期建立父类的引用虽然可以接收后期所有该类的子类对象。但是只能使用父类中的 功能，不能使用子类中的特有功能，因为前期的程序无法知道后期的子类的特有内容的。但 是前期的程序可以使用子类覆盖了父类的方法的内容。  

2. 根据BlueFi的A0、A1、A2等三个模拟输入引脚在未触摸、被触摸时的模拟输入值的变 化规律，设定合适的被触摸阈值，将三个触摸盘当作3种开关输入，以及A和B按钮两种 输入，使用 这5种开关输入分别控制喇叭输出5种不同音调并持续125ms。即，当A按钮 被按下时播放一种音 调并持续125ms，当P1触摸盘被触摸时播放另一种音调并持续125ms。 
    ```CPP
    #include <BlueFi.h>  
    int ping=0;  
    int i=0,b=0;  
    void setup() {  
        Serial.begin(115200);  
        pinMode(45, OUTPUT);  
        digitalWrite(45, LOW);  
        pinMode(5, INPUT_PULLDOWN);  
        pinMode(11, INPUT_PULLDOWN);  
        digitalWrite(45, HIGH);  
    }  
    void loop() {  
    uint16_t a0= analogRead(A0);  
    uint16_t a1= analogRead(A1);  
    uint16_t a2= analogRead(A2);  
    bluefi.aButton.loop();    
    bluefi.bButton.loop();    
    if ( bluefi.aButton.isPressed()) {  
            tone(46,277);  
            delay(150);  
            noTone(46);}  
    else if ( bluefi.bButton.isPressed()) {  
            tone(46,330);  
            delay(150);  
            noTone(46);}    
    
    ```

2. 使用Arduino平台的模拟输入接口的APl，用C语言编程实现以下功能：   
    1）对BlueFi的A0引脚的模拟信号连续采样5次并保存在一个数组中；   
    2）编写程序处理1)中数组的算术平均值当作输出值；   
    3）编写程序确定1)中数组的中值当作输出值；   
    4）分两种情况：未触摸A0引脚、触摸A0引脚时，对比2)和3)的输出值之间的区别，并简要说明  

    
    ```cpp
    #include <BlueFi.h>
    
    int a[5]={0} ;
    int zhong=0 ;int sum=O;int i=0 , b=0 ;
    void sortArray(uint8_t a[],l){
        uint8_t i,j,temp;
        for(i=0;i<l-1;i++){
            for(j=i+1;j<l;j++){
                if(a[i]>a[j]){
                    temp=a[i];
                    a[i]=a[j];
                    a[j]=temp;
                }
            }
        }
    
    }
    void setup (){
        Serial.begin (9600) ;
    }
    void loop(){
        for (i=0;i<5; i++){
        uintl6_t b= analogRead (A0);a[i]=b;
        sum=sum+a[ i];}
        sum=sum/5;
        sortArray(a,5);zhong=a[2];
        Serial.println ( "ping" );Serial.println (sum) ;
        Serial.println ( " zhong" );Serial.println (zhong) ;delay (5000) ;
    }
    
    ```


1. 需要使用MCU 的一个I/O 引脚控制一个中间继电器，请设计一个接口电路,并说明有效电平。已知继电器线圈的工作电压为DC12V、电流不大于60mA.  

2. 参照LED 类接口的定义，请设计继电器类的软件接口(给出全部源代码)，并给出用法示例。 
```cpp

class RELAY {  
    public:  
        RELAY(uint8_t pin);  
        void on(void);  
        void off(void);  
        void toggle(void);//切换状态  
bool state(void);//读取状态  
    private:  
        bool __isInited;  
        bool __state;  
        uint8_t __pin;
};  
RELAY::RELAY(uint8_t pin){
    __pin = pin;
}
RELAY::on(void){
    __state = 1;
    digitalWrite(__pin,__state);
}
RELAY::off(void){
    __state = 0;
    digitalWrite(__pin,__state);
}
RELAY::toggle(void){
    __state = !__state;
    digitalWrite(__pin,__state);
}

//应用
RELAY relayA=RELAY(8);

```
3. 使用本节定义的LED 类和Button 类软件接口，以及BlueFi 的白光LED 和按钮A 实现以下 流程和功能:  
1)初始状态白光LED 灭;  
2)短按按钮A 后亮起白光LED;  
3)双击按钮A(连续的间隔不大于600ms)后白光LED 快速闪烁(每秒亮灭次数不少于5 次);  
4)  长按按钮A(按下时间不小于1.5s)后白光LED 慢闪(每秒亮灭1 次)。  
butten 类中定义了双击，长按，符合题目要求，如果需要精准控制可以修改butten2.h 文件  #define LONGCLICK_MS        2000//长按时间2s  
#define DOUBLECLICK_MS      400//双击间隔400ms  
代码  
```CPP
#include <BlueFi.h>
void setup() {  
    bluefi.begin();  
    bluefi.whiteLED.off();//初始状态白光LED 灭  
}  

void loop() {  
    bluefi.aButton.loop(); // update the state of A-button  
//根据Button2.h 短按为1 双击为2 长按为4  
static uint8_t state = bluefi.aButton.getClickType();

if(bluefi.aButton.getClickType()!=0 )
    state = bluefi.aButton.getClickType

switch(state){  
 	case 1 : bluefi.whiteLED.on ();break;
 	case 2 :    
 	 	bluefi. whiteLED.on();//每秒亮灭次数5 次  
   	   	delay(100);  
   	   	bluefi. whiteLED.off();  
   	   	delay(100);  
 	break;  
 	case 4 :    
 	 	bluefi. whiteLED.on();      delay(100);  
   	   	bluefi. whiteLED.off();      delay(100);  
 	break;  
break;}}   
```


## I2C
1. 查阅“双向三态门”电路及其逻辑，并根据图5.2的“线与”接口电路，请试着使用双向三态门单元改进I2C接口单元的硬件接口电路，并分别描述主机发送-从机接收、从机发送-主机接收的两种工作模式的控制信号状态。

    ![](https://theembeddedsystem.readthedocs.io/en/latest/_images/i2c_interface_wires_and.jpg)

    大概了解概念即可，不会考的

2. 根据图5.5所示的双向电平电压转换电路，请简要分析其工作过程。

    ![](https://theembeddedsystem.readthedocs.io/en/latest/_images/i2c_interface_level_shifter.jpg)

    以下为翻译的芯片原文
    在进行电平转换时要考虑以下三个情况:
    1. 没有设备拉低总线时。
        - 低电压区域由它自带的下拉电阻拉到3.3V，gate = 3.3 sourcesource = 3.3此时MOS管是断开状态，两个区域都是高电平状态。但两个区域的电压不同。
    2. 一个3.3V的设备拉低总线时。
        - MOS管的gate=3.3v source = 低 MOS管导通，然后整条线都被拉低到低电平
        且电压相同
    3. 一个5V的设备拉低总线时
        - MOS管的gate=3.3v source = 低 MOS管导通，然后整条线都被拉低到低电平
        且电压相同
        2和3 即为线与功能

3. 当你设计一个嵌入式系统时所用到的I2C功能组件通讯接口速度不一致，请给出合理的解决方案。
    当高速接口向低速接口发送信号时，则使用高倍的采样器对信号进行采样，将高频信号转化为低频信号

    当低频信号向高速接口发送信号时，可以通过软件将高频信号转化为低频信号，然后再使用

4. 单主-多从结构的I2C通讯接口中仅使用7位宽从机地址即可连接上百个I2C功能组件，请说明7位从机地址的作用，并简述主机访问某个从机的过程。  
    当主机需要访问某个从机的某个/某些寄存器时，首先发出7位从地址和1位“R/W”组成的“读/写指定从地址”的指令帧， 当“R/W=1”时为读，反之为写。与从地址匹配的从机被选择，即被选中的从机的传输控制状态机被激活。

    接着主机发出寄存器地址信息帧，根据从机上寄存器资源(和从机的功能)的多少，或许超过1个字节就需要使用批量传输模式，被选中的从机将会把接收到的地址信息传入地址译码器， 于是对应地址的寄存器被选择。现在我们的I2C接口主机已经选择指定的从机及其内部的寄存器。

    最后，主机和从机的传输控制状态机将会根据第一帧的“R/W”位信息完成进一步操作。如果“R/W=1”，主机驱动SCL输出同步时钟信号，从机上被选择的寄存器内容自动填入输出移位寄存器， 并随着SCL同步时钟逐位顺序地输出到SDA线上，主机驱动SCL的同时会在SCL下降沿出采样SDA线并移入输出移位寄存器。如果“R/W=0”，主机驱动SCL输出同步时钟信号， 同时在SCL低电平期间将输出移位寄存器的内容逐位顺序地输出到SDA线上，同时从机随着SCL同步时钟信号采样SDA线并移入输入移位寄存器，一个字节传输完毕后， 将输入移位寄存器的字节内容保存到被选择寄存器中。
    
    简而言之，一次I2C通讯接口操作包括三步，主机使用7位从机地址和读/写控制位选中I2C总线上的从机，然后指定从机的寄存器(起始)地址，最后读/写从机的寄存器。 

5. 当MCU片上I2C功能单元工作在主机模式时，以读取某I2C接口的传感器数据为例，简述SCL和SDA信号的输出方向和两者关系。
    SCL 主机发送从机接收
    SDA 从机发送主机接收

6. 以I2C通讯接口软件的分层抽象为例，简述硬件层、硬件抽象层、BSP(或中间层)、用户层等各层的功能和作用，并总结分层抽象软件结构的优缺点。

    ![](https://theembeddedsystem.readthedocs.io/en/latest/_images/i2c_interface_software_structure.jpg)

    硬件层：除了硬件电路设计前需查阅具体的MCU那些I/O引脚可用于I2C接口，以及系统所用的I2C组件的电平电压是否一致外，其他工作几乎都是软件接口设计， 根据MCU片上功能单元的存储器映射机制，可以想象这些软件的工作就是访问存储器单元配置I2C接口(包括时钟速度、引脚、数据发送和接收中断等)、 使能和禁止I2C接口，以及中断服务程序等底层操作。幸运的是， 我们无须编写这些代码，源文件都由半导体厂商提供。

    硬件抽象层：I2C接口的硬件抽象层具有承上启下的作用，封装合理的I2C接口硬件抽象层是系统内所有I2C功能组件的共享代码。向下访问MCU硬件层接口(那些具体的MCU的存储器资源访问)实现I2C接口的基本协议， 包括启动时序“beginTransmission”、停止时序“endTransmission”、字节帧批量输出“write()”、输入“requestFrom()”和“read()”等，以及数据接收中断“onReceive()”(仅从机模式)、 主机请求中断“onRequest()”(仅从机模式)等中断服务程序。向上提供I2C通讯协议的实现接口。

    BSP：调用硬件抽象层的接口访问寄存器实现I2C组件的功能封装，这部分工作属于BSP的一部分。 I2C接口软件的BSP部分的基本实施规则就是，隐藏寄存器及其访问操作， 按照I2C组件的功能封装参数配置和功能操作接口，譬如设置温湿度传感器分辨率、获取当前的环境湿度或当前温度、配置加速度传感器的量程、读取当加速度的3分量等。

    用户层：用户层调用特定开源板的BSP接口实现传感器应用，如环境温度或湿度测量及处理(滤波、显示、存储到本地或云端)、根据加速度和陀螺仪的分量值估算姿态、 根据当前姿态角调整飞控系统驱动马达转速等。

    分层式结构究竟其优势何在？
    1、开发人员可以只关注整个结构中的其中某一层；
    2、可以很容易的用新的实现来替换原有层次的实现；
    3、可以降低层与层之间的依赖；
    4、有利于标准化；
    5、利于各层逻辑的复用。

    分层式结构同样也具有一些缺陷：
    1、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。
    2、（增加功能较为繁琐）有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。 

7. 在Arduino平台的I2C硬件抽象层中，为什么“beginTransmission()”、“endTransmission()”和“setClock()”是主机模式专用的接口？
    begin 产生start时序
    end 产生end时序
    set 设置时钟频率
    这些都是只有主机（发送机）才能做（需要做）的事情

8. 参照图5.8的流程，设计I2C接口的“主机写后读”的操作流程，即“主机写-从机读-(无STOP时序)-主机请求-从机写”的操作流程。




1. 简述计算机系统的并行扩展接口、串行扩展接口之间的主要区别，各自的优缺 点。  

    主要区别
    
    串行扩展接口的数据和控制信息是一位接一位地传送出去的，线路简单。并行扩展接口的数据是各位同时传送出去，传输率比串口快，线路复杂。  
    
    各自的优缺点
    串行扩展接口的速度会慢一些，但传送距离较并行口更长，成本低，适用于远距离传输。  
    并行扩展接口的速度快，但抗干扰能力差，适用于近距离传输，比如打印机。 

2. I2C通讯接口的Start、ACK、Stop时序阶段各有什么作用?  

    START  是传输信号的开始标志  
    ACK 是接收者的应答，常用于多字节数据传输，保证传输的同步  
    STOP 是传输信号的结束标志  
    START ACK STOP  都是为了保证同步，防止传输出错  

3. 了解编写伪码程序的基本规则，请结合本课PPT第10页的读、写操作时序图， 分别4种I2C读写操作的伪码程序:写指定外设的单个寄存器、连续写指定外设 的n个寄存器、读指定外设的单个寄存器、连续读指定外设的m个寄存器。  

## UART

1. 异步串行通讯使用起始位、停止位、接收控制单元对RxD信号使用过采样处理等机制避免收发双方波特率偏差、噪声干扰等引起的误码。 请简要说明UART接收控制单元从RxD接收一个字节数据的过程。

    过采样处理 - 起始位 - 校验位 - 停止位 

2. 已知某系统的UART功能单元输入的时钟信号频率为16MHz，且波特率发生器所用的自动重装计数器是递增的模式，按照图7.7所示的UART结构， 请分别给出1,200、9,600、19,200、57,600、115,200、250,000、1,000,000和4,000,000等8种波特率所对应的预分频数(Prescaler)和计数器重装值， 并计算每一种波特率的偏差。
    考纲没这个东西，先放一下

3. 编写几种测试程序，验证第7.2节给出的FIFO队列的控制算法。提示，入列测试，出列测试，队列满时的入列测试，队列为空时的出列测试。
    编程题有可能考到

==注意是指针在动，而不是队列在动，队列是不动的==
```cpp
const uint8_t sizeFIFO = 12;
typedef uint8_t typeElement;
typedef struct {
  uint8_t front, rear, count;
  typeElement elements[sizeFIFO];
} typeFIFO;

void fifoInit(typeFIFO* fifo) {
  fifo->front=0; fifo->rear=0; fifo->count=0;
}
bool fifoIn(typeFIFO* fifo, typeElement dat) {
  if ( (fifo->front==fifo->rear) && (fifo->count==sizeFIFO) )
    return false; // FIFO queue is full!
  else {
    fifo->elements[fifo->rear] = dat; // push it to queue
    fifo->rear = (fifo->rear + 1) % sizeFIFO; // move the pointer
    fifo->count += 1; // queue number plus one
    return true;
  }
}
bool fifoOut(typeFIFO* fifo, typeElement* dat) {
  if ( (fifo->front==fifo->rear) && (fifo->count==0) )
    return false; // FIFO queue is empty!
  else {
    *dat = fifo->elements[fifo->front]; // pop it from queue
    fifo->front = (fifo->front + 1) % sizeFIFO; // move the pointer
    fifo->count -= 1; // queue number minus 。one
    return true;
  }
}

```

1. I2C和SPI都是典型的同步串行通讯接口。请查阅相关资料，并从通讯总线拓扑、波特率、 半/全双工模式等方面对比IPC和SPI通讯接口的区别。  

    SPI 总线是一种4 线总线  
    I2C 总线是二线制同步串行总线。  

    (1)  I2C 总线不是全双工（半双工），2 根线SCL SDA。SPI 总线实现全双工，4 根线SCK CS MOSI  
    MISO  
    (2)  I2C总线是多主机总线，通过SDA上的地址信息来锁定从设备。SPI总线只有一个主设备， 
    主设备通过CS 片选来确定从设备  
    (3)  I2C 总线传输速度在100kbps-4Mbps。SPI 总线传输速度更快，可以达到30Mbps 以上。  (4)  I2C 总线空闲状态下SDA SCL 都是高电平。SPI 总线空闲状态MOSI MISO 也都是  SCK 是由 
    CPOL 决定的  
    (5)  I2C 总线scl 高电平时sda 下降沿标志传输开始，上升沿标志传输结束。SPI 总线cs 拉低标志传输开始，cs 拉高标志传输结束    
    (6)  I2C 总线是SCL 高电平采样。SPI 总线因为是全双工，因此是沿采样，具体要根据CPHA 
    决定。一般情况下master device 是SCK 的上升沿发送，下降沿采集  
    (7)  I2C 总线和SPI 总线数据传输都是MSB 在前，LSB 在后（串口是LSB 在前）  
    (8)  I2C 总线和SPI 总线时钟都是由主设备产生，并且只在数据传输时发出时钟  
    (9)  I2C 总线读写时序比较固定统一，设备驱动编写方便。SPI 总线不同从设备读写时序差别 
    比较大，因此必须根据具体的设备data sheet 来实现读写，相对复杂一些。  


2. 根据电子版教材图6.3所示的两种SPI通讯接口的拓扑结构，简要说明主机向“SPI从机 2#”写、读数据的过程，以及该过程中接口信号的状态变迁。  

    ![PPT课后题2021-09-19-16-49-34](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-49-34.png)

    SPI 主机需要向2#从机写数据时时，只需要将该从机的片选信号NSS 置为有效电平，同时其 他从机的片选信号都被置为无效电平，当SPI 通讯接口软件将待发送的数据写入发送数据缓 冲器，并启动数据发送过程，数据将被自动装载到移位寄存器，  并以最高位(MSB)先发送的 规则随着同步时钟SCK 顺序地将数据逐位从MOSI 发出，同时从机SPI 接口将随着同步时钟 SCK 逐位地将数据位移入移位寄存器，传输完成将NSS 置为无效。  

    当主机需要从从机读取数据时，从机首先将待发送的数据写入发送数据缓冲器，当主机将 2#从机的片选信号NSS 置为有效电平时自动将数据加载到从机的移位寄存器，  随着同步时   
    
    钟信号SCK 仍遵循MSB 先发送的规则将数据顺序地逐位从MISO 发出，同时主机SPI 接口将 随着同步时钟SCK 逐位地将数据移入移位寄存器，所有数据位移入完毕后，主机移位寄存器 的数据自动被加载到接收数据缓冲器，传输完成将NSS 置为无效。  

    两个移位寄存器被两个独立的串行数据线首尾串联成环形， 譬如一个字节(8位)数据从主 机移入从机的同时从机上的一个字节数据 也正好移入主机。绝大多数现代SPI通讯接口的 接收和发送数据缓冲器都采用FIFO(先进先出)结构、接收和发送完毕的中断机制。  

3. 使用BlueFi调试并运行“康威(Conway)生命游戏的模拟”的程序(参见电子版教材6.2节)， 并仔细阅读程序，绘制程序的流程，简要说明该程序的工作过程。  
工作过程  
![PPT课后题2021-09-19-16-49-56](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-49-56.png)

首先对lcd屏幕进行初始化，然 
后利用initGrid()对网格进行初始化，然后通过一次次的计算、延时、绘制网格，最后做成游戏的效果。  

其生存法则为：  

如果当前网格的元胞是活体，且 周围活着的邻居数目(至多 8	个) 为2 个或3 个时，保持原状态  

如果当前网格的元胞是活体，且 周围活着的邻居数目小于2个时， 生物群落太小，该元胞死亡  

如果当前网格的元胞是活体，且 周围活着的邻居数目大于3个时， 生物群落太大，该元胞死亡  

如果当前网格的元胞是死亡的， 且周围活着的邻居数目是3 个， 该元胞变为活体  

如果当前网格的元胞是死亡的， 且周围活着的邻居数目不是3个， 保持原状态   





## Can总线

1. 假设某CAN2.0B总线上有3个节点同时需要发送消息，消息ID都是采用11位，ID分别为0x7F0、0x3F4、0x481， 请问这三个消息谁最先发送成功，谁最后发送成功？请说明原因。

2. 根据Can总线的消息优先级机制，0为显性，1为隐性，消息ID最小的最先成功，所以优先级顺序0x3F4 -> 0x481 -> 0x7F0

