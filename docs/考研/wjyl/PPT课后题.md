

==欢迎==

## 第一章

![PPT课后题2021-09-19-16-36-09](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-36-09.png)

![PPT课后题2021-09-19-16-37-01](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-37-01.png)

## 第二章
 



1.查阅资料了解RISC-V内核相关的软硬件产品，并分类介绍。 

RISC-V设计(国内)： 
中国开放指令⽣态联盟 http://crva.ict.ac.cn/ 
芯来科技、平头哥半导体等 
RISC-V设计(国外)： 
SiFive 
WesternDigitalCorporation(WDC) 
软件⼯具： 
GCCtools 
RTOS 
其他： 
Rocket：（UCB）标量处理器：64位、5级流水线、但发射顺序执行处理器， 
BOOM：（UCB）超标量乱序执行处理器；BOOM也是采用Chisel编写，全部代码大约9000行； 
Sodor：（UCB）针对教学的32位开源处理器。Chisel编写，支持5种处理器：单周期处理 器、2级流水线处理器、3级流水线处理器、5级流水线处理器、可执行微码的处理器 
ORCA：嵌入式应用处理器，支持指令：RV32IM（也可以：RV32E/RV32I） 
PicoRV32：是一个RV32IMC指令的实现，由RISC-V开发者Clifforfwolf实现，但重新设 计了trap/interrupt/interruptreturn，采用了一种简化的方式，所有代码是由verilog 编写的；其特点是小巧在Xilinx7上占用大小为750~2000个LUT 
Shakti：印度理工学院的一个项目，由Verilog编写，其使用了大量第三方IP, 
YARVI:是RISC-V爱好者TommyThorn设计发布的简单的、32位开源处理器，实现了RV32I， 使用Verilog，目标是为了能够清晰准确的实现RV32I 
Pulpino：由苏黎世联邦理工大学与意大利博洛尼亚大学联合开发。32位，指令集： 
RV32I/RV32C/RV32M，扩展了RISC-V指令；多核 
GRVIPhalanx：大规模并行RISC-V（最多到千核），2~3级流水线，32位，其中在Artix-7 35T开发板上已经实现32RISC-V处理器；在PYNQ-Z1上实现了80核；在UltraScale上实现了1680核的RISC-V； 

蜂鸟：国内最早比较成熟的RISC-V实现，由胡振波（现在芯来创始人）开发，使用Verilog 设计。其开源CPU为E200：使用2级流水线   



2.开源CPU内核的三种形态是哪些? 

开源指令集、开源实现(半导体设计)、开源⼯具链 


3.指令集和工具链（含编译器和链接器）之间存在什么关系？据此简要说明RISC-V体系才是真正的开源CPU内核 

RISC-V提供了特权级指令和用户级指令，同时提供了详细的RISC-V特权级指令规范和 RISC-V用户级指令规范的详细信息。 

对于设计CPU来说，工具链是软件开发人员和cpu交互的窗口，没有工具链，对软件开发人 员开发软件要求很高，甚至软件开发者无法让cpu工作起来。在cpu设计中，工具链的开发 是一个需要巨大工作量的工作。如果用RISC-V来设计芯片，芯片设计公司不再担心工具链 问题，只需专注于芯片设计，RISC-V社区已经提供了完整的工具链，并且RISC-V基金会持 续维护该工具链。 

RISC-V实现了开源指令集、开源实现(半导体设计)、开源⼯具链，所以RISC-V体系才是真正的开源CPU内核RISC-V体系才是真正的开源CPU内核  

## 第三章


第三次作业 
2-1MCS-51 单片机内部主要有哪些功能部件?各部件的主要作用是什么? 
(1)	ALU 算术逻辑运算单元：完成所有算术运算和逻辑运算。 
(2)	ACC 累加器：①作为寄存器暂存数据②作为逻辑运算单元的目的寄存器或源寄存器，并 
存储运算结果。 
(3)	PSW 程序状态字：PSW 是一个8 位的动态寄存器，其各个位的值反映了程序的执行状 
态信息。 
(4)	SP 堆栈指针：SP 是一个8 位的专用寄存器，它用于指示堆栈顶部在RAM 中的位置。 
(5)	PC 程序计数器：PC 是一个16 位的程序计数器。PC 用于保存下一条将要执行的指令在 
程序存储器中的地址，按此地址CPU 可以从相应的程序存储器中取指令。 
(6)	DPTR 数据指针：DPTR 的最主要用途是用于访问CPU 的外部数据存储器和IO 端口，可 
以访问空间的大小为64 KB。 
(7)	RAM 静态随机存储器：所有MCS-51 系列单片机的片内都至少具有128B 的RAM，用于 
执行指令时的缓存、通用寄存器和堆栈。 
(8)	ROM(只读存储器)对绝大多数的MCS-51 单片机来讲，ROM 是用于存放程序指令和常数 
表的存储器。 
(9)	I/O(输入/输出)端口实现开关式输入/输出控制。 
(10) 时钟和控制信号这个单元可以产生MCS-51 单片机工作必需的时钟信号，以及执行程序 
指令的控制信号，它是MCS-51 单片机稳定工作的保障。 
(11) 除上面提到的各功能单元外，MCS-51 系列单片机内部还有通用同步/异步通信收发器 
(USART)、定时器/计数器(Timer/Counter)以及中断(Interrupt)等部件。 
2-2MCS-51 单片机内部包括哪些类型的存储器﹖简述它们的作用和区别。 
RAM:MCS-51 系列单片机的数据存储器包括片内RAM 和外部扩展的RAM 等。用于执行指令 时的缓存、通用寄存器和堆栈。 
ROM:对绝大多数的MCS-51 单片机来讲，ROM 是用于存放程序指令和常数表的存储器. 
2-3 使用内部程序存储器和外部程序存储器时，EA 如何使用? 
内部-EA 高电平 
外部-EA 接地 
2-4 程序计数器PC 是多少位的寄存器?它是否为特殊功能寄存器?作用是什么? 
PC 是一个16 位的程序计数器,不属于特殊功能寄存器，PC 用于保存下一条将要执行的指令 在程序存储器中的地址，按此地址CPU 可以从相应的程序存储器中取指令。 
2-58051 内核和8052 内核的单片机主要有哪些区别? 
1）程序存储器（ROM）：8051 的容量是4KB，8052 的容量是8KB; 
2）数据存储器(RAM)：8051 的容量是128b，8052 的容量是256b; 
3）可编程定时/计数器：8051 有2 个，8052 有3 个； 
4）中断源：8051 有5 个，8052 有6 个。 
2-6μP监控电路能够提高单片机系统的可靠性吗? 
可以，μP监控电路实现了对单片机程序运行状态的监视，一旦出现单片机程序“跑飞”或 进入意外的“死循环”时，该电路能够发出单片机复位脉冲，将单片机复位后，重新开始执 行程序，避免单片机死机。   

第三次作业 

2-7 根据图2-9，简述MCS-51 系列单片机内部的高128B 数据存储器与SFR 之间的区别，以 及如何访问这些区域的存储器。 
在8052 内核中比8051 内核中多出的128 BRAM 被称为高128 BRAM，这部分存储器的地址 范围与SFR 重叠，但是，在物理上高128B RAM 与SFR 区域是两块相互独立的存储器。注意， 为了区分这两部分独立的存储器区域，软件在访问高128BRAM 时，仅可以使用间接地址寻 址方式，而在访问SFR 时仅可以使用直接地址寻址方式。 
2-8MCS-51 系列单片机有哪两种节电运行模式?它们有什么区别?如何控制MCS-51 系列单片 机进入节电模式运行? 
节电模式和掉电模式、 
节电模式：在空闲模式下，MCS-51 单片机进入睡眠状态，CPU 停止取指令和执行指令的操 作，但是片内的其它所有功能部件仍在继续工作，如定时/计数器、异步串行接口和中断系 统等仍正常工作。 
掉电模式：在掉电模式下，内部RAM 中的所有内容将保持不变，其它所有部件包括振荡器 电路都停止工作。 
需要进入低功耗空闲节电模式时，可以由软件将PCON 的最低位IDL 置位，等待2 个机器周 期后单片机立即进入空闲模式。 

2-9 在MCS-51 系列单片机的Reset 引脚处于高电平期间,MCS-51 单片机处于什么状态?在该 引脚处于低电平期间，MCS-51 单片机又处于什么状态? 
当该高电平保持时，CPU一直处于复位状态。当RST引脚上的高电平被撤消转为低电平后(CPU 被复位之后)，CPU 将从程序的起点重新开始顺序执行程序，即CPU 进入运行状态。 
2-10 MCS-51 系列单片机的堆栈操作包括进栈和出栈两种，简述执行这些操作时SP 的值如 何改变。MCS-51 单片机按照什么原则执行堆栈操作? 
当执行PUSH(进栈操作)指令时，SP 先自动加1，然后将目标单元中的内容传送到堆栈区;而 在执行POP(出栈操作)指令时，硬件先自动把SP 所指向的堆栈区内容传送到目标单元，然后 SP 自动减1。MCS-51 单片机的堆栈操作按照“先进后出”的原则进行。 
2-11 MCS-51 系列单片机有多少个通用寄存器?分几个组?分别占用内部RAM 的哪些地址?如 何区分? 
32 个分四组0 区的地址为00H-07H，1 区的地址为08H-0FH，2 区的地址为10H-17H，3 区的 地址为18H-1FH，工作寄存器的选择由程序状态字PSW 中RS0、RS1 位的值决定，当RS1、 RS0 为00 时选中0 区，为01 时选中1 区，为10 时选中2 区，为11 时选中3 区。 
2-12 简述标志位Cy.AC.OV 和P 的作用. 
Cy(PSW.7):进位(或借位)标志位。当执行单元在执行数值算术加法和减法运算时，运算的结果 如果出现进位或借位,Cy 将被自动置位(Cy=“1”)，否则被自动清零(Cy=“0”).当然Cy	也可 以被软件置位或清零。 
AC(PSW.6):低半字节进位标志位(或称辅助进位位)。当执行单元在执行数值算术加法和减法 运算时，低4 位(即低半字节)运算结果有进位或借位，AC 将被自动置位，否则被自动清零。 OV(PSW.2):算术运算结果溢出标志位。在执行数值算术加法和减法运算时，根据执行过程中 位6 和位7 的进位或借位情况，CPU 自动将OV 置位(OV=“1”)或清零(OV=“0”)。具体规 则:执行加法或减法过程中位6 和位7 中仅有一个位有进位或借位时，OV 被置位，否则被清   

第三次作业 
零。另外，执行数值算术乘法运算时，如果乘积大于255，OV 被置位，否则被清零;在执行 数值算术除法运算时，如果除数为О，OV 被置位，否则被清零。 
P(PSW.0):累加器ACC 内容的奇偶校验位。在程序执行过程中，每执行一条指令后CPU 自动 按ACC 的内容将Р清零或置位。规则是:ACC 的8 个位中值为1 的位个数是奇数个时，P 被 自动置位(P=“1”):否则，Р被自动清零(P=“O”)-P 在异步串行通信过程中有特殊意义，使 用该位可以容易实现奇偶校验，常用于接收方检验接收到的数据是否有误。 

2-13 简述晶体振荡周期和机器周期、ALE、PSEN 信号之间的关系。 
一个机器周期＝6 个状态周期=12 个振荡周期。 
在一个机器周期内，PSEN 和ALE 信号一样出现两次，即在一个机器周期内CPU 将访问程序 存储器两次。因此，在一个机器周期内，CPU 可以从程序存储器中读取两个字节的指令码。  



## 第四章


1. ECS的实时性指的是什么?为什么说计算机使用Linux、Windows等OS属于非实时的? 

实时操作系统意味着，某个事件发生所触发的任务必须在预定时间内完成(不是最快完 成，而是在预定的截止时间之前完成)。 

一个实时操作系统面对变化的负载（从最小到最坏的情况）时必须确定性地保证满足时间要 求。请注意，必须要满足确定性，而不是要求速度足够快！例如，如果使用足够强大的CPU， Windows在CPU空闲时可以提供非常短的典型中断响应，但是，当某些后台任务正在运 行时，有时候响应会变得非常漫长，以至于某一个简单的读取文件的任务会长时间无响应， 甚至直接挂死。这是一个基本的问题：并不是Windows不够快或效率不够高，而是因为它 不能提供确定性，所以，Windows不是一个实时操作系统。 

2. 假设某时间片轮转型RTOS的ECS软件包含3个任务，简述任务调度器的工作过程。 

任务调度器能够并行处理多任务的机制是，将CPU的时间分割为多个时间片并分配给已经 创建的3个任务，每个任务占用CPU的一个时间片，当正在执行的任务的时间片消耗完毕 时，调度器实施任务切换(即将正在执行的任务挂起，继续执行下一个任务)，每一个任务按 分配的时间片占用CPU一定时间后被挂起，如此无穷地循环，让我们感觉多个任务被并行执行。 

3. 假设某抢占型RTOS的ECS软件包含3个任务，简述任务调度器的工作过程。 

抢占型RTOS的任务调度器相对复杂，每个任务不仅有自己的时间片，还有自己的优先级，正在执行的低优先级任务的时间片可能会被高优先级的任务抢占。抢占型RTOS将CPU的时间分割为多个时间片并分配给已经创建的3个任务，每个任务占 用CPU的一个时间片，优先执行高优先级任务，当正在执行的任务的时间片消耗完毕时，调度器实施任务切换(优先执行高优先级任务)，每一个任务按分配的时间片占用CPU一定 时间后被挂起，如此无穷地循环，让我们感觉多个任务被并行执行。   

4. ECS软件使用RTOS的优点和缺点分别有哪些? 

优点：支持任务驱动和多任务的软件设计方法能够将复杂的嵌入式 系统软件分割成多个易 于实现的简单任务软件，不仅易维护还能确保实时性。 

缺点：任何RTOS都需要额外占用嵌入式系统有限的ROM空间和RAM空间。 

- 其一是，RTOS种类繁多且无统一的标准 API，甚至对开发环境和软件工具也有特殊要求(没 有统一的开发环境); 
- 其二是，昂贵的商用RTOS 授权费，虽然也有很多种免费的甚至开源 的RTOS可以选择，但是没有技术支持也可能会增加软件 开发时间和技术成本;
- 其三是，RTOS的Bug， 虽然所有RTOS研发者都认为自己已经尽力做到最好，但复杂的RTOS内 核软件和相关中间件本身就是庞大的软件系统，有Bug是在所难免的。 

5. 某ECS系统包含4个按钮输入、4个模拟输入、1个图形显示器输出、1个通讯接口（可接收指令和数据，可发送应答数据)等资源，所有输入均支持中断模式，请使用中断与查询 
相结合的编程范例绘制流程图实现以下功能： 

1）周期地执行模拟转换、保存和显示； 

2）按钮可设置模拟转换周期； 

3）当通讯接口收到新命令时，将当前的模拟转换结果发送出去。  

![PPT课后题2021-09-19-16-42-42](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-42-42.png)


## 第五章


第五次作业  

1. C++和Python都属于⾯向对象编程(Object Oriented Programming)语⾔。请查阅资料了解OOP 具有哪些特征？请逐⼀举例且简要说明每⼀个特征  

①封装性：封装是指将一个计算机系统中的数据以及与这个数据相关的一切操作语言（即描述每一个对象 的属性以及其行为的程序代码）组装到一起，一并封装在一个有机的实体中，把它们封装在一个“模块” 中，使得软件结构的相关部件的实现“高内聚、低耦合”的“最佳状态”便是面向对象技术的封装性所需 要实现的最基本的目标。对于用户来说，对象是如何对各种行为进行操作、运行、实现等细节是不需要刨 根问底了解清楚的，用户只需要通过封装外的通道对计算机进行相关方面的操作即可。大大地简化了操作 的步骤，使用户使用起计算机来更加高效、更加得心应手。  

②继承性：其主要指的是两种或者两种以上的类之间的联系与区别。继承，顾名思义，是后者延续前者的 某些方面的特点，而在面向对象技术则是指一个对象针对于另一个对象的某些独有的特点、能力进行复制 或者延续。分为单继承与多继承，如果从继承中包含的内容进行划分，则继承可以分为四类，分别为取代 继承、包含继承、受限继承、特化继承。  

③多态性：从宏观的角度来讲，多态性是指在面向对象技术中，当不同的多个对象同时接收到同一个完全 相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态性是指在一 组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用，即便这若干个具 有相同函数名的函数所表示的函数是不同的。  

2. 按照Arduino开源社区惯例，每⼀个开发板的MCU的I/O引脚映射成⼀组序数。BlueFi开源板的引 脚定义“../packages/adafruit/hardware/nrf52/0.20.5/variants/bluefi/”⽂件中。这种处理⽅法的 ⽬的之⼀是提⾼Arduino程序源码的可移植性，请说明原因  

其一是软件开发者不必直接访问半导体厂商提供的驱动库，；其二是提高Arduino软件的可移植性。节省 开发时间，“variant.cpp”文件就是将原始的I/O引脚编号映射为0～46这样的序数所有Arduino开源 板都有一个可编程的LED指示灯， 并称之为“内建的LED”。所以下⾯的示例程序可被任⼀Arduino板 执⾏：  
void setup() {  
 pinMode(BUILTIN_LED, OUTPUT);  
}  
void loop() {  
 digitalWrite(BUILTIN_LED, HIGH);  
 delay(500);  
 digitalWrite(BUILTIN_LED, LOW);  
 delay(500);  
}   


## 第六章

1. 需要使用MCU 的一个I/O 引脚控制一个中间继电器，请设计一个接口电路,并说明有效电平。已知继电器线圈的工作电压为DC12V、电流不大于60mA.  
利用三极管放大电路  


2. 参照LED 类接口的定义，请设计继电器类的软件接口(给出全部源代码)，并给出用法示例。 BlueFi_RELAYs.h文件  
#ifndef ___BLUEFI_RELAYS_H_  
#define ___BLUEFI_RELAYS_H_  
#include <Arduino.h>  
class RELAY {  
    public:  
        RELAY(uint8_t pin);  
        uint8_t getAttachPin(void);  
        void on(void);  
void off(void);  
        void toggle(void);//切换状态  
bool state(void);//读取状态  
    private:  
        bool __isInited;  
        bool __state;  
        uint8_t __pin;};  
#endif // ___BLUEFI_LEDS_H_    

第六次作业   

BlueFi.h需要添加的代码  
#ifndef ___BLUEFI_H_#  
define ___BLUEFI_H_  
#include "utility/BlueFi_RELAYs.h"  
class BlueFi {  
  public:  
    BlueFi();  
    void begin(bool LCDEnable=true,    
bool SerialEnable=true);  
    RELAY aRELAY= RELAY (8);//8 号接继电器  
  private:  
    bool __isInited;};  
extern BlueFi bluefi;  
#endif // ___BLUEFI_H_  
 


应用示例  
#include <BlueFi.h>  void setup() {  
    bluefi.begin();  
    bluefi.aRELAY.off();  
}  

void loop() {  
    bluefi.aRELAY.on();      delay(3600000);  
    bluefi.aRELAY.off();      delay(900000);  
}  

3. 使用本节定义的LED 类和Button 类软件接口，以及BlueFi 的白光LED 和按钮A 实现以下 流程和功能:  
1)初始状态白光LED 灭;  
2)短按按钮A 后亮起白光LED;  
3)双击按钮A(连续的间隔不大于600ms)后白光LED 快速闪烁(每秒亮灭次数不少于5 次);  
4)  长按按钮A(按下时间不小于1.5s)后白光LED 慢闪(每秒亮灭1 次)。  
butten 类中定义了双击，长按，符合题目要求，如果需要精准控制可以修改butten2.h 文件  #define LONGCLICK_MS        2000//长按时间2s  
#define DOUBLECLICK_MS      400//双击间隔400ms  
代码  
```CPP
#include <BlueFi.h>
void setup() {  
    bluefi.begin();  
    bluefi.whiteLED.off();//初始状态白光LED 灭  
}  

void loop() {  
    bluefi.aButton.loop(); // update the state of A-button  
//根据Button2.h 短按为1 双击为2 长按为4  
switch(bluefi.aButton.getClickType()){  
 	case 1 : bluefi.whiteLED.on ();break;    
 	case 2 :    
 	 	bluefi. whiteLED.on();//每秒亮灭次数5 次  
   	   	delay(100);  
   	   	bluefi. whiteLED.off();  
   	   	delay(100);  
 	break;  
 	case 4 :    
 	 	bluefi. whiteLED.on();      delay(100);  
   	   	bluefi. whiteLED.off();      delay(100);  
 	break;  
break;}}   
```

## 第七章

1. 查阅运算放大器的相关资料，简要说明PGA(可编程增益的运放)的工作原理；并根据电子 版教材图4.6和图4.7，简要说明PGA在模拟输入通道中的益处。  

工作原理  

可编程增益放大器含全平衡差动放大器模块、译码器模块和电阻开关阵列模块，全平衡差动 放大器模块中的负反馈电阻分压器的电阻比确定该放大器的最大增益，通过译码器模块的译 码结果控制电阻开关阵列模块衰减输入信号的衰减量，最终实现该放大器的增益的可编程。 

益处  

虽然ADC等数字化器件的输入量程范围是固定的，通过调整PGA的增益可以把不同量程范 围的V(t)信号调整到[Vref-, Vref+]范围。所以通过PGA可以满足更宽量程范围的模拟信 号，不仅如此使用多路模拟信号选择器和PGA可以让多个模拟输入信号共用一个ADC等数 字化器件，这种模拟前端有利于降低成本。  
  
2. 使用Arduino平台的模拟输入接口的APl，用C语言编程实现以下功能：   
1）对BlueFi的A0引脚的模拟信号连续采样5次并保存在一个数组中；   
2）编写程序处理1)中数组的算术平均值当作输出值；   
3）编写程序确定1)中数组的中值当作输出值；   
4）分两种情况：未触摸A0引脚、触摸A0引脚时，对比2)和3)的输出值之间的区别，并简要说明  

    ```cpp
    #include <BlueFi.h>
    
    int a[5]={0} ;
    int zhong=0 ;int sum=O;int i=0 , b=0 ;
    void sortArray(uint_8 a[],l){

    }
    void setup (){
        Serial.begin (9600) ;
    }
    void loop(){
        for (i=0;i<5; i++){
        uintl6_t b= analogRead (A0);a[i]=b;
        sum=sum+a[ i];}
        sum=sum/5;
        sortArray(a,5);zhong=a[2];
    Serial.println ( "ping" );Serial.println (sum) ;
    Serial.println ( " zhong" );Serial.println (zhong) ;delay (5000) ;
    }

    ```

Arduino 可以将0－5伏特的电压输入信号 映射到数值0－1023。当把A0 接地时为0， 接5v 时为1023。  
触摸时平均值大于中位数数值明显增大大 约在900 左右，这与人身上所带电有关。  
未触摸时平均值大于中位数，大约在400 左 右波动很大。  
分别接0v，5v 时中位数更加准确。   


## 第八章


1. 查阅C++抽象类和接口的“多态”概念，并简述多态的优缺点。  

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。设计抽象类（通常称为  ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化 对象，它只能作为接口使用。  
多态是指同样的消息被不同类型的对象接受时导致不同的行为。所谓消息是指对类的成员函 数的调用，不同的行为是指不同的实现，也就调用不同的函数。换言之，多态指的就是用同 样的接口访问功能不同的函数，从而实现“一个接口，多种方法”。  
多态的优点：  
代码组织结构清晰  
可读性强  
利于前期和后期的扩展以及维护  对拓展开放，对修改关闭  
弊端：前期建立父类的引用虽然可以接收后期所有该类的子类对象。但是只能使用父类中的 功能，不能使用子类中的特有功能，因为前期的程序无法知道后期的子类的特有内容的。但 是前期的程序可以使用子类覆盖了父类的方法的内容。  

2. 根据BlueFi的A0、A1、A2等三个模拟输入引脚在未触摸、被触摸时的模拟输入值的变 化规律，设定合适的被触摸阈值，将三个触摸盘当作3种开关输入，以及A和B按钮两种 输入，使用 这5种开关输入分别控制喇叭输出5种不同音调并持续125ms。即，当A按钮 被按下时播放一种音 调并持续125ms，当P1触摸盘被触摸时播放另一种音调并持续125ms。 

#include <BlueFi.h>  
int ping=0;  
int i=0,b=0;  
void setup() {  
    Serial.begin(115200);  
    pinMode(45, OUTPUT);  
    digitalWrite(45, LOW);  
    pinMode(5, INPUT_PULLDOWN);  
    pinMode(11, INPUT_PULLDOWN);  
    digitalWrite(45, HIGH);  
}  
void loop() {  
uint16_t a0= analogRead(A0);  
uint16_t a1= analogRead(A1);  
uint16_t a2= analogRead(A2);  
bluefi.aButton.loop();    
bluefi.bButton.loop();    
if ( bluefi.aButton.isPressed()) {  
        tone(46,277);  
        delay(150);  
        noTone(46);}  
else if ( bluefi.bButton.isPressed()) {  
        tone(46,330);  
        delay(150);  
        noTone(46);}    



1. 简述面向对象编程的构造函数和析构函数的作用。  

构造函数是对象创建完成后第一个被对象自动调用的函数。起初始化值的作用  
析构函数作用和构造函数正好相反，是对象被销毁之前最后一个被对象自动调用的函数。用 于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间。  

2. 编译、下载并调试示例程序——BSP文件夹的examples/mic_plotter/mic_plotter.ino，分 析程序的功能和结构，绘制该示例程序的流程图。    
![PPT课后题2021-09-19-16-47-22](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-47-22.png)

3. 探究定时器(Timer)和定时中断的精度。使用本节的课程示例3(ch04_04_ex3.ino)和示例  4(ch04_04_ex4.ino)的源代码，以及BlueFi和Arduino IDE的串口监视器，了解设定的定时中 断间隔时间和实际的时间间隔之间的偏差大小(以微秒为单位)，分析引起偏差的原因。  

偏差大概24us  
timer0其实其内部是每隔 1.024ms 产生一次中断, 不是每 1ms,但是在 millis( ) 函数内有 个调整机制, 大约 41.6 次中断会偷偷调整 1 millis,但也会产生误差。  
Timer1和软件定时器没有调整所以就会和millis产生偏差  




## 第九章




1. 简述计算机系统的并行扩展接口、串行扩展接口之间的主要区别，各自的优缺 点。  

主要区别  
串行扩展接口的数据和控制信息是一位接一位地传送出去的，线路简单。并行扩 展接口的数据是各位同时传送出去，传输率比串口快，线路复杂。  
各自的优缺点  
串行扩展接口的速度会慢一些，但传送距离较并行口更长，成本低，适用于远距 离传输。  
并行扩展接口的速度快，但抗干扰能力差，适用于近距离传输，比如打印机。  

2. I2C通讯接口的Start、ACK、Stop时序阶段各有什么作用?  

START  是传输信号的开始标志  
ACK 是接收着的应答，常用于多字节数据传输，保证传输的同步  STOP 是传输信号的结束标志  
START ACK STOP  都是为了保证同步，防止传输出错  

3. 了解编写伪码程序的基本规则，请结合本课PPT第10页的读、写操作时序图， 分别4种I2C读写操作的伪码程序:写指定外设的单个寄存器、连续写指定外设 的n个寄存器、读指定外设的单个寄存器、连续读指定外设的m个寄存器。  

写指定外设的单个寄存器  

if  主机发出START 命令then  
主机发送接收器件地址  
主机发出WRITE 的信号  
if ACK 校验发送成功then  
主机发送存储器的地址  
if ACK 校验发送成功then  
主机发送一个字节的数据then  
if ACK 校验发送成功then  
主机发送一个停止时序  
 	 	 	 	I2C 总线进入内部自编程循环，将字节写入外部寄存器  
eles  返回上一步  
eles  返回上一步  
eles  返回上一步    



写指定外设的n 个寄存器  
 


if  主机发出START 命令then  
主机发送接收器件地址  
主机发出WRITE 的信号  
if ACK 校验发送成功then  
主机发送存储器的地址  
if ACK 校验发送成功then  
 	while i=0；i<n；i++  
主机发送一个字节的数据  
if ACK 校验发送失败then  
返回上一步  
end  
主机发送一个停止时序  
 	 	 	I2C 总线进入内部自编程循环，将字节写入外部寄存器  
eles  返回上一步  
eles  返回上一步  


读取指定外设的单个寄存器  

if  主机发出START 命令then  
主机发送接收器件地址  
主机发出WRITE 的信号  
if ACK 校验发送成功then  
主机发送存储器的地址  
if ACK 校验发送成功then  
主机发送START 信号  
主机发送接收器件地址  
主机发出READ 的信号  
if ACK 校验发送成功then  
主机读取一个字节的数据  
 	 	 	 	主机发送STOP 信号  
eles  返回上一步  
eles  返回上一步  
eles  返回上一步    


读取指定外设的m 个连续寄存器  

if  主机发出START 命令then  
主机发送接收器件地址  
主机发出WRITE 的信号  
if ACK 校验发送成功then  
主机发送存储器的地址  
if ACK 校验发送成功then  
主机发送START 信号  
主机发送接收器件地址  
主机发出READ 的信号  
while i=0；i<n；i++  
主机发送一个字节的数据  
if ACK 校验发送失败then  
返回上一步  
End  
主机发送STOP 信号  
eles  返回上一步  
eles  返回上一步   

## 第十章


  

1. I2C和SPI都是典型的同步串行通讯接口。请查阅相关资料，并从通讯总线拓扑、波特率、 半/全双工模式等方面对比IPC和SPI通讯接口的区别。  

SPI 总线是一种4 线总线  

![PPT课后题2021-09-19-16-49-18](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-49-18.png)


I2C 总线是二线制同步串行总线。  


![PPT课后题2021-09-19-16-49-25](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-49-25.png)




(1)  I2C 总线不是全双工（半双工），2 根线SCL SDA。SPI 总线实现全双工，4 根线SCK CS MOSI  
MISO  
(2)  I2C总线是多主机总线，通过SDA上的地址信息来锁定从设备。SPI总线只有一个主设备， 
主设备通过CS 片选来确定从设备  
(3)  I2C 总线传输速度在100kbps-4Mbps。SPI 总线传输速度更快，可以达到30Mbps 以上。  (4)  I2C 总线空闲状态下SDA SCL 都是高电平。SPI 总线空闲状态MOSI MISO 也都是  SCK 是由 
CPOL 决定的  
(5)  I2C 总线scl 高电平时sda 下降沿标志传输开始，上升沿标志传输结束。SPI 总线cs 拉低 
标志传输开始，cs 拉高标志传输结束    

  

(6)  I2C 总线是SCL 高电平采样。SPI 总线因为是全双工，因此是沿采样，具体要根据CPHA 
决定。一般情况下master device 是SCK 的上升沿发送，下降沿采集  
(7)  I2C 总线和SPI 总线数据传输都是MSB 在前，LSB 在后（串口是LSB 在前）  
(8)  I2C 总线和SPI 总线时钟都是由主设备产生，并且只在数据传输时发出时钟  
(9)  I2C 总线读写时序比较固定统一，设备驱动编写方便。SPI 总线不同从设备读写时序差别 
比较大，因此必须根据具体的设备data sheet 来实现读写，相对复杂一些。  


2. 根据电子版教材图6.3所示的两种SPI通讯接口的拓扑结构，简要说明主机向“SPI从机 2#”写、读数据的过程，以及该过程中接口信号的状态变迁。  


![PPT课后题2021-09-19-16-49-34](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-49-34.png)




SPI 主机需要向2#从机写数据时时，只需要将该从机的片选信号NSS 置为有效电平，同时其 他从机的片选信号都被置为无效电平，当SPI 通讯接口软件将待发送的数据写入发送数据缓 冲器，并启动数据发送过程，数据将被自动装载到移位寄存器，  并以最高位(MSB)先发送的 规则随着同步时钟SCK 顺序地将数据逐位从MOSI 发出，同时从机SPI 接口将随着同步时钟 SCK 逐位地将数据位移入移位寄存器，传输完成将NSS 置为无效。  


当主机需要从从机读取数据时，从机首先将待发送的数据写入发送数据缓冲器，当主机将 2#从机的片选信号NSS 置为有效电平时自动将数据加载到从机的移位寄存器，  随着同步时   

  

钟信号SCK 仍遵循MSB 先发送的规则将数据顺序地逐位从MISO 发出，同时主机SPI 接口将 随着同步时钟SCK 逐位地将数据移入移位寄存器，所有数据位移入完毕后，主机移位寄存器 的数据自动被加载到接收数据缓冲器，传输完成将NSS 置为无效。  

两个移位寄存器被两个独立的串行数据线首尾串联成环形， 譬如一个字节(8位)数据从主 机移入从机的同时从机上的一个字节数据 也正好移入主机。绝大多数现代SPI通讯接口的 接收和发送数据缓冲器都采用FIFO(先进先出)结构、接收和发送完毕的中断机制。  

3. 使用BlueFi调试并运行“康威(Conway)生命游戏的模拟”的程序(参见电子版教材6.2节)， 并仔细阅读程序，绘制程序的流程，简要说明该程序的工作过程。  
工作过程  
![PPT课后题2021-09-19-16-49-56](https://image.wxydejoy.top/img/PPT课后题2021-09-19-16-49-56.png)

首先对lcd屏幕进行初始化，然 
后利用initGrid()对网格进行初始 

化，然后通过一次次的计算、延 时、绘制网格，最后做成游戏的 效果。  

其生存法则为：  

如果当前网格的元胞是活体，且 周围活着的邻居数目(至多 8	个) 为2 个或3 个时，保持原状态  

如果当前网格的元胞是活体，且 周围活着的邻居数目小于2个时， 生物群落太小，该元胞死亡  

如果当前网格的元胞是活体，且 周围活着的邻居数目大于3个时， 生物群落太大，该元胞死亡  

如果当前网格的元胞是死亡的， 且周围活着的邻居数目是3 个， 该元胞变为活体  

如果当前网格的元胞是死亡的， 且周围活着的邻居数目不是3个， 保持原状态   


