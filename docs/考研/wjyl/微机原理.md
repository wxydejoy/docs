==笔记==

## 导论

### 冯诺依曼和哈弗架构的区别
冯诺依曼架构

<img src="https://image.wxydejoy.top/img/微机原理2021-09-20-16-24-03.png!max" alt="微机原理2021-09-20-16-24-03" style="zoom: 25%;" />

哈佛架构

<img src="https://image.wxydejoy.top/img/ComputerStructure_2.jpg!max" alt="../_images/ComputerStructure_2.jpg!max" style="zoom:25%;" />

哈佛计算机体系结构将程序存储器独立出来，甚至程序存储器单元拥有独立的地址总线和数据总线。执行程序 期间程序存储器是只读的状态，非易失的存储器的读操作速度比写操作快很多个数量级，因此很多人认为哈佛结构的计算机体系架构比 冯.诺伊曼结构更合理。
### 微内核、存储器、片上外设(如定时/计数器、ADC、I2C、UART、CAN等)、AHB和APB总线、总线桥等组成的MCU/SoC

<img src="https://image.wxydejoy.top/img/bluefi_functional_unit.jpg!max" alt="../_images/bluefi_functional_unit.jpg!max" style="zoom:33%;" /> 

<img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-07-55.png!max" alt="微机原理2021-09-22-20-07-55" style="zoom: 50%;" /> 

### C/C++等编译型语言和Python等解释型语言之间的区别(程序的执行过程和执行效率等)以及他们的源码转换为机器码的软件工具和过程
![../_images/code2bin.jpg!max](https://image.wxydejoy.top/img/code2bin.jpg!max)

C/C++是典型的编译型高级语言，程序源码必须经过工具链处理成特定机器可执行的机器语言程序才能让计算机执行，程序的执行效率很高， 但是源码的任何小改动都必须再用工具链处理一次。

Python是典型的解释型高级语言，脚本程序被特定机器的Python解释器逐行地转换 成机器语言程序片段并在当前运行环境立即执行立即输出结果，脚本语言无需预先编译，仅在运行时才逐行解释、执行、输出，编写和修改源码 的效率很高(相较于C/C++语言，Python语言的程序员们的工作效率更高)，但Python程序的执行效率较低，Python脚本程序依赖特定的解释器。

<img src="https://image.wxydejoy.top/img/ec_software_dev_download.jpg!max" alt="../_images/ec_software_dev_download.jpg!max" style="zoom: 33%;" />

### Bootloader。

微控制器进入下载/更新程序状态时所执行的专用程序被称作Bootloader。

### 软件开发流程

<img src="https://image.wxydejoy.top/ppt/P018.jpg!max" alt="img" style="zoom: 25%;" />

### 硬件开发流程

ECS的硬件开发流程(主要步骤)
- 需求分析和资源(含软硬件工具)分析
- 硬件功能定义和原型验证
- 供电系统(拓扑)
- 硬件设计(原理图、仿真和验证)
- PCB布局(形状和尺寸的约束)
- PCB生产
- 元件焊接
- 软硬件集成调试、测试和验证
- 改进
<img src="https://image.wxydejoy.top/img/ec_dev_flow.jpg!max" alt="../_images/ec_dev_flow.jpg!max" style="zoom: 33%;" />

## 系统硬件

1. 微内核、存储器、片上外设(如定时/计数器、ADC、I2C、UART、CAN等)、AHB和APB总线、总线桥等组成的MCU/SoC

   不同体系仅作了解，重要的是那张图

   - ARM体系

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-00-47.png!max" alt="微机原理2021-09-22-20-00-47" style="zoom: 33%;" />

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-00-33.png!max" alt="微机原理2021-09-22-20-00-33" style="zoom: 33%;" />

      比较图2.2和图2.3不难发现，M0和M0+的区别很小，M0+支持单周期I/O及其接口，并增加软件调试的跟踪接口，而且这些都是可选择性的组件。显然，功能组件方面 M0+完全兼容M0。事实上，ARM Cortex-M0与ARM Cortex-M3的CPU内核都采用3级流水线(Pipeline)，而ARM Cortex-M0+的CPU内核却采用2级流水线， 因此M0+的动态功耗明显低于M0和M3。

      高速CPU和低速外设之间的矛盾如何解决呢？半导体技术工程师使用总线桥技术很好地解决这一问题：CPU和存储器之间不仅采用高速总线还 增加Cache(高速缓存)单元，CPU与低速外设之间采用总线桥和低速外设总线，这样的总线桥隔离技术不仅能够保持CPU拥有高速时钟，并保持低速外设的低成本。

   - RISCV体系

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-02-45.png!max" alt="微机原理2021-09-22-20-02-45" style="zoom:33%;" />

      显然，无论采用那种CPU架构体系，MCU的CPU内核(含中断控制器等)、片上数据和程序存储器、高速总线接口(含Cache等)、片上高速外设、低速外设总线接口(含总线桥)、 片上低速外设等功能组件及其互联总线都是必要的，如果采用开放的互联总线标准，最终这些MCU的区别都是一些小细节，譬如外设的多少、I/O引脚的多少等。
   - 其他体系

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-04-11.png!max" alt="微机原理2021-09-22-20-04-11" style="zoom:33%;" />  <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-04-21.png!max" alt="微机原理2021-09-22-20-04-21" style="zoom: 50%;" />

   - 共性图

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-07-55.png!max" alt="微机原理2021-09-22-20-07-55" style="zoom:50%;" />

      设计描述如下： 
      - 1) CPU、存储器(包括 SRAM、FlashROM)都属于高速功能部件，应使用高速总线 AHB连接他们，确保 CPU 访问存储器的速度尽可能快，譬如数个 CPU 时钟周期；I2C、ADC 等片上外设功能单元属于低速功能部件，他们的访问速度一般是 CPU 时钟周期的数十倍或数百倍，应使用低速外设总线连接他们；AHB-APB 总线桥不仅将 AHB 和 APB 两种速度的总线连接起来，还能起到隔离作用，CPU 访问 AHB 总线上的设备时仅耗费有限个时钟周期，但访问 APB 总线上的外设需要数十个时钟周期。
      - 2) USB 虽然属于 MCU 片上外设，但 USB 功能单元的需要很高时钟速度(譬如 USB2.0高达 48MHz)，而且 USB 接口的数据吞吐量大。因此将 USB 功能单元连接到 AHB 总线上。 
      - 3) 数字电路的功耗直接受时钟速度影响，时钟速度越高功耗则越大，反之功耗越小。功能简单且时钟速度极低的片上外设功耗极低；高速 CPU 是高性能和计算能力需要高速的存储器；使用两种(或更多种)不同速度的总线连接不同时钟速度的片上功能单元的设计有利于降低 MCU 的功耗。 



2. 不同计算性能MCU/SoC的结构对比

   这里跟前面一样

   <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-00-47.png!max" alt="微机原理2021-09-22-20-00-47" style="zoom: 33%;" />

   <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-00-33.png!max" alt="微机原理2021-09-22-20-00-33" style="zoom:33%;" />

   比较图2.2和图2.3不难发现，M0和M0+的区别很小，M0+支持单周期I/O及其接口，并增加软件调试的跟踪接口，而且这些都是可选择性的组件。显然，功能组件方面 M0+完全兼容M0。事实上，ARM Cortex-M0与ARM Cortex-M3的CPU内核都采用3级流水线(Pipeline)，而ARM Cortex-M0+的CPU内核却采用2级流水线， 因此M0+的动态功耗明显低于M0和M3。

   高速CPU和低速外设之间的矛盾如何解决呢？半导体技术工程师使用总线桥技术很好地解决这一问题：CPU和存储器之间不仅采用高速总线还 增加Cache(高速缓存)单元，CPU与低速外设之间采用总线桥和低速外设总线，这样的总线桥隔离技术不仅能够保持CPU拥有高速时钟，并保持低速外设的低成本。

3. 存储器功能分区和存储器映射机制，

   “一切皆地址”是计算机系统资源管理的基本规则，虽然RISC已经完全把内核中的寄存器完全独立并使用Ri这样的别名来访问，但CISC的内核寄存器不仅有别名也被分配独立地址。

   - ARM

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-18-13.png!max" alt="微机原理2021-09-22-20-18-13" style="zoom:33%;" />

      ARM要求所有被授权设计和生产ARM Cortex-M半导体产品都必须使用32位地址总线宽度， 整个存储器系统为4GB(2^32个字节)容量并按照表2.1规定的功能分区使用，将系统的片上SRAM和FlashROM、片外扩展的SRAM和FlashROM、片上外设、片外扩展的外设等资源， 以及ARM Cortex-M系列微内核私有的外设资源(如SysTick、NVIC等)全部按功能分类映射到8个0.5GB的不同功能分区中，无论是访问变量还是访问某个I/O引脚(读其状态或 写/改变其状态)统一为访问4GB地址空间内的某些地址单元。

      比较自由

   - RISC-V

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-20-08.png!max" alt="微机原理2021-09-22-20-20-08" style="zoom: 25%;" />

      采用RISC-V ISA的MCU的存储器系统和映射规则并没有统一的规定，而是完全由设计师来确定。

      完全自由
      由设计师制定

   - ESP32

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-20-34.png!max" alt="微机原理2021-09-22-20-20-34" style="zoom:33%;" />

      ESP32仅仅把整个4GB地址空间分割成3个区域：数据区(含FlashROM、SRAM和外设)、指令区(含FlashROM)、数据和指令混合区(仅RTC-Slow-Memory)。 其中数据区又分为外部扩展的SRAM最大可达8MB(2个4MB区)，以及片上外设和片上数据存储器各占512KB地址空间；指令区包含片上的776KB指令存储器和11512KB片外扩展 的FlashROM存储器；数据和指令混合区仅仅是片上RTC供电区的8KB慢速SRAM。

4. 程序存储空间的功能分区、Bootloader、用户程序空间等分区的主要功能

   - 程序存储器的功能分区

      ![微机原理2021-09-22-20-21-13](https://image.wxydejoy.top/img/微机原理2021-09-22-20-21-13.png!max)

      虽然ARM为Cortex-M4系列MCU预留0.5GB地址空间的Code分区，地址范围为0x00000000~0x1FFFFFFF，但是实际MCU芯片的片上FlashROM容量没有超过2MB的！上图中的三种 MCU的片上FlashROM容量分别为1MB(SAMD51x20)、256KB（STM32F401)和1MB(nRF52840)，他们的容量与0.5GB相比不足1/500。

      SAMD51x20将Code分区的前80MB分割为4各部分：1MB FlashROM从起始地址开始，然后将前48MB的其余空间保留(未来可能会设计更大容量FlashROM时再用)，接着的16MB用于 Cache控制器，剩下的16MB留给QSPI接口扩展的外部FlashROM。整个Code分区都属于可执行指令区，这意味着SAMD51x20可以直接从片外扩展的QSPI接口的FlashROM中取指令 并执行指令，即该MCU支持片外扩展的16MB的QSPI接口FlashROM。

      STM32F401是ST公司ARM Cortex-M4系列MCU产品中最低配的，仅有256KB片上FlashROM且被分配在Code分区的0x08000000~0x0803FFFF地址空间，另外还有一个30KB的专用 FlashROM区——System Memory被分配在0x1FFFFFFF~0x1FFF7A0F地址空间，以及仅有8各字节的电源电源检测和看门狗定时器等复位控制单元的配置信息被分配在0x1FFFC000~ 0x1FFFC007地址空间。其中System Memory区30KB FlashROM专门用于存储Bootloader程序，关于Bootloader的内容将在第3章专门介绍。值得注意的是，STM32F401的 Code分区最前面的256KB别名区，这是一个非物理存储器区，与Cortex-M3/M4的位带别名区的用法相似，访问Code分区的这个别名区时根据MCU的Boot引脚电平来决定对应的物理 存储器分区，具体细节参加第3章的内容。

   - Bootloader

      嵌入式系统CPU的工作状态和工作模式如图2.25所示，总体上分为2种状态：调试状态和执行指令状态。
      ![微机原理2021-09-22-20-24-17](https://image.wxydejoy.top/img/微机原理2021-09-22-20-24-17.png!max)
      引导阶段的程序被称作“Bootloader”，这一小片程序将执行一些必要的硬件单元初始化操作，如RAM初始化操作、外部ROM存储器接口初始化操作等，为执行主程序做好准备工作。 在Bootloader，嵌入式系统CPU可能处于两种工作模式：特权的线程模式和异常处理模式。“特权的线程”指的是，这个期间可以用指令访问系统内所有资源。“异常处理”包括软件 和硬件异常、中断请求响应等，除以零是典型的软件异常，非法访问某些存储地址将导致硬件异常。在异常处理模式，绝大多数都是执行中断服务程序响应系统的中断请求， 所有嵌入式系统的软件开发者都会尽可能避免软件或硬件异常，但“万一出现的异常”必须被正确地处理否则将导致系统出现不可预测的行为。

   - 用户程序空间

5. 时钟与复位电路，低能耗模式，多电源域、时钟树及其节能控制方法。

   睡眠与深度睡眠模式
   CPU时钟速度越高动态功耗越大，CPU速度越高则必须有与之匹配的高速存储器， 高速存储器也会增加功耗，为保持嵌入式系统的计算能力和功耗之间的平衡，MCU的半导体设计阶段就确保CPU支持正常/全速工作模式和多种低功耗工作模式，譬如睡眠模式和深度睡眠模式； 让CPU极短时间内高速运行待事务处理完毕后立即进入长时间睡眠，这是从软件设计角度降低功耗的一种方法；CPU进入睡眠之前关闭大功耗外设的电源，这是从系统硬件电路设计 角度降低功耗的一种方法。

   降低高速CPU动态功耗的有效方法之一是，降低CPU核工作电压，譬如STM32F401的CPU核仅有1.2V，由于CPU核与片上存储器之间的连接信号密度较大(如32位地址总线和 32位数据总线)，必须降低片上存储器的工作电压以简化接口。然而片上外设，尤其使用I/O引脚的片上外设则与外部供电电源电压保持一致。

   当CPU进入(轻)睡眠模式时， CPU将停止工作，但必须使用状态维持的电源控制(State retention power gating)技术确保CPU内部寄存器内容维持不变，片上振荡器、存储器和外设仍继续工作， 被中断唤醒后将立即继续工作。当CPU进入深睡眠模式时，不仅CPU完全掉电工作，振荡器和片上外设全部停止工作，仅片上SRAM数据仍保留，被外部中断或复位唤醒后将 花费更长时间重新开始工作。很显然，(轻)睡眠的功耗远大于深睡眠。

   - 多电源域

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-29-34.png!max" alt="微机原理2021-09-22-20-29-34" style="zoom:33%;" />

      当我们让嵌入式系统CPU进入睡眠或深睡眠的低功耗模式之前必须控制负载开关切断系统外设的电源才能达到降低系统功耗之目的，如果外设的供电电压是多种类型(如1.8V、 2.75V、3.3V、5V等都是常用的外设工作电压)则必须使用多路负载开关来分别控制每一个外设的电压开关。这样的供电电源设计称作多电源域，各个电源域的工作电压和功率不同， 而且有独立的负载开关控制。这种电源域设计也常用于MCU芯片内部，用于控制片上外设电源开关。MCU片内的电源拓扑如图2.28所示。
   
   - 复位
   
      - MCU的复位源
         - 外部复位
            - 复位引脚(与外部复位电路、复位按钮、看门狗定时器复位等连接)
         - 内部复位
            - 低电压复位 (Brownout Reset)
            - 上电复位 (Power On Reset)
            - 看门狗定时器复位 (Watchdog Reset)
            - 软件复位 (Software Reset/Reboot)
            - 唤醒复位 (Wakeup Reset)

   - 时钟树 

      <img src="https://image.wxydejoy.top/img/微机原理2021-09-22-20-32-23.png!max" alt="微机原理2021-09-22-20-32-23" style="zoom: 50%;" />
      换句话说，GD32VF103的RISC-V微内核的时钟是可以关闭的(进入低功耗工作模式)，而且时钟频率是可调节的。 使用更多种可编程分频器和时钟门控处理CK_AHB时钟信号为片上外设提供不同频率的基准工作时钟。

   - 本章总结

      为满足更高计算性能需要微内核的时钟速度越来越高，但传统片上外设的速度仍很低， 复杂的片上供电系统、时钟树等能够确保高性能内核和外设的低功耗特性。几乎所有的MCU和SoC都遵循“一切皆地址”原则将片上资源全部映射到存储器系统内， 像访问数据存储器一样地访问某些存储地址单元即可实现对片上外设的编程，对整个存储器系统进行功能分区并引入低成本的易用MPU管理各功能区域的权限， 允许CPU直接从片外扩展串行存储器执行程序，与传统的并行接口扩展片外存储器相比不仅极大地减少MCU引脚数目和PCB面积，还有利于降低系统成本。

## 系统软件

1. C/C++等编译型语言和Python等解释型语言之间的区别(程序的执行过程和执行效率等)，以及他们的源码转换为机器码的软件工具和过程，

这个在前面已经讲过

2. C/C++编程语言的基本数据类型、基本语法、子程序及其调用，类的封装、基本结构、接口设计和实例化操作

   C/C++编程语言的基本数据类型、基本语法、子程序及其调用这里不再讨论
   | 类型   | 符号 | 关键字               | 位数 | 范围             |
   | ------ | ---- | -------------------- | ---- | ---------------- |
   | 整型   | 有   | `(signed)int`        | 16   | -32768~32767     |
   | 整型   | 有   | `(signed)shot`       | 16   | -32768~32767     |
   | 整型   | 有   | `(signed)long`       | 32   | -2^16~2^16-1     |
   | 整型   | 无   | `unsigned int`       | 16   | 0~65535          |
   | 整型   | 无   | `unsigned short int` | 16   | 0~65535          |
   | 整型   | 无   | `unsigned  long int` | 32   | 0~2^32-1         |
   | 实型   | 有   | `float`              | 32   | 3.4e-38~3.4e38   |
   | 实型   | 有   | `double`            | 64   | 1.7e-308~1.7e308 |
   | 字符型 | 有   | `char`               | 8    | -128~127         |
   | 字符型 | 无   | `unsigned char`      | 8    | 0~255            |

   类的封装如下、接口设计和实例化操作在后面

   ```c
   class LED {
   public:
      LED(uint8_t pin){
         __isInited = 1;
         __state = 0;
         __pin = pin;
         pinMode(__pin, OUTPUT);
         digitalWrite(__pin, __state);
      }
      uint8_t getAttachPin(void){
         return __pin;
      }
      void on(void){
         __state = 1;
         digitalWrite(__pin, __state);
      }
      void off(void){
         __state = 0;
         digitalWrite(__pin, __state);
      }
      void toggle(void){
         __state = (__state)?0:1;
         digitalWrite(__pin, __state);
      }
      bool state(void){
         return __state;
      }
   
   private:
      bool __isInited;
      bool __state;
      uint8_t __pin;
   };
   
   ```

 

3. 软件集成开发环境(IDE)的组成部分，常用数据处理算法(查找、统计、排序、循环移位等)。 
   
   IDE：编辑、编译、调试、下载等功能的集成平台

   常用数据处理算法

   排序

   冒泡

   ```cpp
   #include<stdio.h>
   //冒泡排序算法
   void bubbleSort(int *arr, int n) {
      for (int i = 0; i<n - 1; i++){
         for (int j = 0; j < n - i - 1; j++)
         {
               //如果前面的数比后面大，进行交换
               if (arr[j] > arr[j + 1]) {
                  int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp;
               }
         }
      }
   }

   ```

   选择

   ```cpp

   void SelectionSort(int *arr, int size)
   {
      int i, j, k, tmp;
      for (i = 0; i < size - 1; i++) {
         k = i;
         for (j = i + 1; j < size; j++) {
               if (arr[j] < arr[k]) {
                  k = j;
               }
         }
         tmp = arr[k];
         arr[k] = arr[i];
         arr[i] = tmp;
      }
   }
   ```
   循环移位

   ```cpp
   move(unsigned int value, int n)			/*自定义移位函数*/
   {
      unsigned z;
      if(n>0)
      {
         z = (value >> (16-n)) | (value << n);	/*循环左移的实现过程*/
      }
      else
      {
         n=-n;
         z = (value << (16-n)) | (value >> n);  /*循环右移的实现过程*/
      }
      return z;
   }
   ```

## 系统设计

- 数字输入/输出(按钮和LED指示灯)接口设计和编程控制，
   
   接口设计 注意上拉和下拉电阻。
   
   <img src="https://image.wxydejoy.top/img/微机原理2021-09-25-19-23-40.png!max" alt="微机原理2021-09-25-19-23-40" style="zoom: 25%;" />
   
   BlueFi的A和B按钮是可编程的，两个按钮的电路连接完全相似(除了使用不同的I/O引脚)，图4.1中仅给出A按钮的电路连接。A按钮的接口电路不仅包含片外的按钮， 还包含片内的可配置上拉/下拉电阻，由于A按钮的一端与MCU工作电源连接、另一端与P1.7引脚连接，当A按钮按下时P1.7引脚被强制与电源连接；如果P1.7的内部配置为下拉电阻， 当A按钮释放时P1.7引脚被下拉到电源地。通过读取P1.7引脚的状态确定A按钮的状态，当A按钮按下时读取状态的结果为“1”(即高电平)，当A按钮释放时读取状态的结果为“0”(即低电平)。 当我们将A按钮的状态保存到一个布尔型变量时，如果不采用DMA(直接存储器访问)方式，nRF52840的CPU的工作过程为：将P1.IN寄存器(即0x5000 0810地址单元)读入CPU内部某个寄存器， 然后再将D7位的值(即P1.7引脚的状态)保存到布尔型变量(即“Bit_Band”区的某个地址单元)。

   编程控制

   ```cpp
   class LED {
   public:
      LED(uint8_t pin){
         __isInited = 1;
         __state = 0;
         __pin = pin;
         pinMode(__pin, OUTPUT);
         digitalWrite(__pin, __state);
      }
      uint8_t getAttachPin(void){
         return __pin;
      }
      void on(void){
         __state = 1;
         digitalWrite(__pin, __state);
      }
      void off(void){
         __state = 0;
         digitalWrite(__pin, __state);
      }
      void toggle(void){
         __state = (__state)?0:1;
         digitalWrite(__pin, __state);
      }
      bool state(void){
         return __state;
      }
   
   private:
      bool __isInited;
      bool __state;
      uint8_t __pin;
   };


   ```cpp
   #include <BlueFi.h>
   void setup() {
      bluefi.begin();
      bluefi.redLED.on();
      bluefi.whiteLED.off();
   }

   void loop() {
      bluefi.aButton.loop(); // update the state of A-button
      bluefi.bButton.loop(); // update the state of B-button
      if ( bluefi.aButton.isPressed() ) {
            bluefi.redLED.off();
      } else {
         bluefi.redLED.on();
      }
   }
   ```

- 模拟输入(ADC)接口设计和编程控制
   
   ADC的组成部分图
   
   <img src="https://image.wxydejoy.top/img/微机原理2021-09-25-19-25-40.png!max" alt="微机原理2021-09-25-19-25-40" style="zoom: 50%;" />

   经过数字化的模拟信号仅仅保留采样时刻的信息，为了防止丢失连续信号的原始特征(如频率、幅值等)，采样周期(或频率)的选择非常重要。 程序指令通过控制ADC器件的“START”信号启动采样、量化和转换过程，当AD转换完毕后，通过切换“EOC”信号的电平状态通知系统读取转换结果。 这样结构的ADC器件很容易设计成中断驱动模式，根据采样周期配置MCU的定时器产生周期性中断启动AD转换，并使用ADC的“EOC”信号申请中断， 在“EOC”的中断服务程序内读取AD转换结果。

   大多数嵌入式系统的ADC等数字化器件前端都带有PGA(可编程增益放大器)，以满足更宽量程范围的模拟信号，虽然ADC等数字化器件的输入量程范围是固定的。 如图4.4，ADC器件能够接受的模拟电压输入范围为[Vref-, Vref+]，通过调整PGA的增益可以把不同量程范围的V(t)信号调整到[Vref-, Vref+]范围。

   常用的模拟信号有两种，单端信号和差分信号。本质上，所有模拟信号都是差分形式，单端信号是由信号本身和地信号组成的一种特殊差分信号对。 标准的差分信号对仅需要一对双绞线即可传输信号，无需地信号线，具有极好的抗共模干扰能力和高信噪比等特性。在差分信号处理单元的输入端， 差分电路单元能够将差分信号转换为单端信号。单端模拟信号和差分模拟信号的形式如图4.5所示。

   模拟输入： uint16_t adc_chx_value = ananlogRead(chx)
   模拟输出： analogWrite(chx, value)

- 脉宽调制(PWM)信号发生器的基本原理(递增/递减的计数器、数值比较器、占空比等)和编程控制
   
   PWM(脉冲宽度调制)信号是一种可实现连续信号控制效果的数字信号，由于其实现电路单元全部由数字电路组成，易于集成且成本低，现在的绝大多数MCU都支持可编程PWM信号输出。 相较于DA转换输出的模拟信号，PWM信号具有极强的抗干扰特性，这使得PWM的应用场景非常多，譬如开关电源、电池充电、显示器亮度控制、伺服控制、通信等。

   <img src="https://image.wxydejoy.top/img/微机原理2021-09-25-19-28-41.png!max" alt="微机原理2021-09-25-19-28-41" style="zoom:33%;" />

   <img src="https://image.wxydejoy.top/img/微机原理2021-09-25-19-29-14.png!max" alt="微机原理2021-09-25-19-29-14" style="zoom:33%;" />

   PWM信号发生器由时钟预分频器(Prescaler)、波计数器(Wave Cpunter)或通用计数器(General Counter)、数值比较器(Comparator)等组成，如图4.11所示。
  
   ```cpp
   #include <BlueFi.h>
   void setup() {
   bluefi.begin();
   bluefi.whiteLED.off();
   }
   
   void loop() {
   static uint8_t bv=0, dir=1;
   if (dir) {  // fade up
      bv += 5;  // step length
      if (bv > 250) dir=0;
   } else {    // fade down
      if (bv >= 5) bv -= 5;
      else dir=1;
   }
   bluefi.redLED.bright(bv);
   delay(10);
   }
   ```

- 同步串行通讯接口I2C的多从机共享总线的原理，I2C总线扩展系统功能的软硬件方法。
   - 双工，允许通讯双方之间互相传输数据。按通讯收发机制又分为全双工和半双工
   - 全双工，允许通讯双方同时互相发送和接收数据，这意味着通讯接口拥有2各独立的信息收发通道
   - 半双工，允许通讯双方互相传输数据，但任意时刻仅允许一个发送者(另一个则为接收者)
   - 单工，只允许单方向传输数据，通讯双发的角色是固定的：一个发送者，一个接收者
   - 并行通讯，传统的三总线是典型的并行通讯，每一个时钟周期能够传输半字节/整字节/多字节(由数据总线宽度决定)信息
   - 串行通讯，每一个时钟周期只能传输单个二进制位，将待传输的数据按MSB(最高位)到LSB(最低位)或反之的顺序逐位传输
   - 同步串行通讯，使用独立的数据线和同步时钟线的串行通讯接口，每一个数据位时钟与一个时钟对齐
   - 异步串行通讯，无同步时钟线，仅用一根数据线的串行通讯接口，仅使用一个或若干个特殊同步位来对齐字节数据

   I2C是一种典型的同步串行通讯接口，单个接口支持单主多从、多主多从(但任何时刻仅有一个主机)等模态的多组件间半双工通讯。虽然I2C协议支持多主多从的模态， 但实际应用中绝大多数几乎都是单主多从模态。

   <img src="https://image.wxydejoy.top/img/微机原理2021-09-25-19-33-08.png!max" alt="微机原理2021-09-25-19-33-08" style="zoom: 50%;" />

   理论上，单个I2C接口能够连接高达128个组件。这需要每一个组件拥有一个惟一的7位地址码，称之为I2C从地址，图5.1中的每种I2C接口传感器拥有惟一的从地址。 这意味着，同一个型号的I2C接口组件不能同时连接到单个I2C接口上，除非他的I2C从地址是可配置的。

   I2C接口的两个信号分别称作SCL和SDA，SCL是主设备输出的同步时钟信号，SDA是双向的串行数据信号。虽然SCL是单方向的信号，只能从主设备输出， 但为支持多主多从模态，实际的I2C接口单元的SCL信号仍被定义成双向的。I2C能够实现真正的多组件共享总线应归功于独特的“线与(wire-AND)”接口设计， 如图5.1所示。

   <img src="https://image.wxydejoy.top/img/微机原理2021-09-25-19-34-13.png!max" alt="微机原理2021-09-25-19-34-13" style="zoom: 50%;" />

   上图中两个“线与”接口信号的外部上拉电阻是必须的，上拉电阻的阻值选择与该接口的互联设备数量、传输线长度、分布电容和通讯速度等有关，一般在2K~47K欧之间。图中使用MOS仅是原理性示意的目的， 实际I2C接口组件的硬件实现又多种选择，譬如使用三态门电路。当主机发送-从机接收数据位流时，数据位流的“1”/“0”被转换为“高”/“低”电平随着同步时钟信号SCL而顺序地出现在SDA上， SCL和SDA两个信号都由I2C主机驱动，I2C从机根据SCL信号同步地逐位锁存数据位流信号并形成字节数据。当从机发送-主机接收数据位流时， I2C主机输出同步时钟信号SCL给工作中的从机，I2C从机根据SCL信号同步地将待传输的数据位流逐位地发送到SDA上，同时I2C主机同步地接收数据位流。

   ![微机原理2021-09-25-19-35-20](https://image.wxydejoy.top/img/微机原理2021-09-25-19-35-20.png!max)

   对于I2C通讯接口的数据帧传输，不必刻意区分时序和通讯协议，虽然时序仅规定总线上信号之间时空关系，通讯协议却是更宽泛的概念。 I2C接口的每一次数据传输必须以“START”时序开始并以“STOP”时序终止，由于I2C接口仅支持单字节的数据帧，每帧/字节数据必须以数据接收者的“ACK”为结束。 “START”、“STOP”、“ACK”的作用都是为了“同步”目的，对比单字节和两字节传输时序时会发现“ACK”尤为重要，完全可以把“ACK”理解为字节同步位。 正是这些特殊的同步状态才让I2C通讯接口更加可靠、稳定。

   值得注意的是，I2C通讯接口传输数据位的顺序按最高位(MSB)先发送、最低位(LSB)最后发送。

   I2C通讯接口的连续读/写操作是指，从I2C从机上读取某些连续地址的寄存器内容时，或者向I2C从机上某些连续地址的寄存器顺序地写入内容时，I2C主机首先传输给从机一个待读/待写的寄存器起始地址(仍可以是8/16/32位地址信息)， 然后读取/写入第一个字节，接收者给出“ACK”，接着继续读取/写入下一个字节，接收者给出“ACK”，如此重复直到连续读/写操作完毕，期间不必再指定读取/写入的寄存器地址， 因为每读/写一个字节之后，下一个寄存器地址默认是前一个操作的地址自增1。

   现在我们可以来回答“I2C从地址为什么是7位？” 当主机需要访问某个从机的某个/某些寄存器时，首先发出7位从地址和1位“R/W”组成的“读/写指定从地址”的指令帧， 当“R/W=1”时为读，反之为写。与从地址匹配的从机被选择，即被选中的从机的传输控制状态机被激活。

   接着主机发出寄存器地址信息帧，根据从机上寄存器资源(和从机的功能)的多少，或许超过1个字节就需要使用批量传输模式，被选中的从机将会把接收到的地址信息传入地址译码器， 于是对应地址的寄存器被选择。现在我们的I2C接口主机已经选择指定的从机及其内部的寄存器。

   最后，主机和从机的传输控制状态机将会根据第一帧的“R/W”位信息完成进一步操作。如果“R/W=1”，主机驱动SCL输出同步时钟信号，从机上被选择的寄存器内容自动填入输出移位寄存器， 并随着SCL同步时钟逐位顺序地输出到SDA线上，主机驱动SCL的同时会在SCL下降沿出采样SDA线并移入输出移位寄存器。如果“R/W=0”，主机驱动SCL输出同步时钟信号， 同时在SCL低电平期间将输出移位寄存器的内容逐位顺序地输出到SDA线上，同时从机随着SCL同步时钟信号采样SDA线并移入输入移位寄存器，一个字节传输完毕后， 将输入移位寄存器的字节内容保存到被选择寄存器中。

   简而言之，一次I2C通讯接口操作包括三步，主机使用7位从机地址和读/写控制位选中I2C总线上的从机，然后指定从机的寄存器(起始)地址，最后读/写从机的寄存器。 使用从机惟一地址编码的寻址方法，与传统三总线接口、SPI接口等伪共享总线相比，I2C接口没有专用的从机选择信号线，既节约MCU的I/O引脚又能简化PCB布板。 

## 系统互联

- 面向字节编码的异步串行通讯(UART)的字节同步机制(起始位、停止位、数据位个数、波特率等)、 

   <img src="https://image.wxydejoy.top/img/微机原理2021-09-27-16-14-22.png!max" alt="微机原理2021-09-27-16-14-22" style="zoom:50%;" />

   此外，异步串行通讯的数据传输时序方面也有专用的同步位，包括起始位和停止位，使用这些同步位来确保字节同步。如图7.6(a)所示。异步串行通讯接口的数据参数以字节为基本单元， 每个字节的二进制位数是可配置的，包括5、6、7、8位等4种，最常用的是8位宽度。起始位固定为“0”；停止位固定为“1”，而且停止位的个数是可配置的， 包括0.5、1、1.5、2位等4种，默认采用1个停止位。 

   ![微机原理2021-09-27-16-16-00](https://image.wxydejoy.top/img/微机原理2021-09-27-16-16-00.png!max)

   校验位包括偶校验和奇校验两种类型。一个字节数据的偶校验位指的是，如果组成这个字节的8个二进制中有偶数个“1”，则偶校验位为“1”；反之为”0“。 奇校验位的定义与之相似。异步串行通讯的数据传输格式可配置使用偶校验位或奇校验位，如图7.6(b)，校验位放在停止位之前发送。譬如， 如果采用8位宽的字节，校验位将作为第9个位来传输。接收方将根据校验位类型、校验位的值对接收到的二进制序列的可信度进行评价， 如果校验失败则表示接收到的数据是错误的。

   异步串行通讯的起始位和停止位是非常非常巧妙的设计。前一个字节的传输以停止位结束，数据信号线的状态保持逻辑高电平，开始传输下一个字节的起始位是逻辑低电平。 虽然停止位的个数是可配置的，如果传输的两个字节之间预留数据处理(如准备下一个待发送的数据、保存前一个接收的数据)的时间间隔，停止位的多少已不重要，如图7.6(c)。 目前仅有智能卡(Smart Card)应用(ISO7816-3)的异步串行通讯接口需要使用半个或1.5个停止位，这些应用对时序要求较为严格。

   从图7.6(d)可以看出，使用异步串行通讯接口传输多字节数据时，起始位和停止位保持数据流中相邻字节有明显的界线，接收方使用过采样处理能够准确地从噪声环境中恢复数据流， 甚至自动侦测发送方的波特率信息。

- 数据帧同步机制(帧起始(/头)字节、帧结束(/尾)字节、信息域等)、数据帧检错机制(校验字节)，

   ![微机原理2021-09-27-16-35-49](https://image.wxydejoy.top/img/微机原理2021-09-27-16-35-49.png!max)

- 开放系统互联(OSI)模型及其网络协议分层

   开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。

   ![微机原理2021-09-27-16-31-39](https://image.wxydejoy.top/img/微机原理2021-09-27-16-31-39.png!max)

   1. 物理层

      主要设备：中继器、集线器

      物理层中双绞线的传输距离是有限的，信号会缩减，影响数据的传输。为了使传输的数据能够准确的传输，中继器是可以放大传输信号，保持原数据的准确。
   2. 数据链路层

      功能：完成网络之间相邻结点的可靠传输，通过Mac地址负责主机之间的数据的可靠传输。

      物理层传输的是比特流，而数据链路层传输的是帧。

      主要设备：网卡、网桥、交换机

   3. 网络层

      完成网络中主机间的报文传输（物理层比特流，数据链路层帧），网络层识别的地址是IP地址。

      涉及的协议：IP/IPX

      主要设备：路由器

      路由器：通信中转站，例如快递的中转站，将不同网络和网段进行数据翻译，使其可以相互理解，构成一个大的网络。

   4. 传输层

      是整个网络关键的部分，是实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题。是向下通信服务最高层，向上用户功能最底层。即向网络层提供服务，向会话层提供独立于网络层的传送服务和可靠的透明数据传输。

      主要协议：TCP传输控制协议/UDP用户数据报协议，涉及服务使用的端口号，主机根据端口号识别服务，区分会话。

      TCP协议：解决数据是否完整传输，是否正确

      UDP协议：UDP协议实现了端口，从而使数据包传送到IP地址的基础上，还可以进一步将其送到具体的某一个端口上。

      UDP传输与IP传输相似，但IP协议是ip地址之间的通信，但通信需要多个通信通道，将每个通道分配给每一个进程使用，UDP则是实现端口的通信。

      服务与以及相对应的端口文件：C:\Windows\System32\drivers\etc\servies

      例如：www服务端口号为80

   5. 会话层：主要功能是在两个结点间建立、维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。

      例如：你通过秘书与对方建立联系，则你发出建立联系的请求相当于一个会话，秘书相当于传输层，然后秘书进行拨号联系对方，当对方接通对话，则会话的连接建立。

   6. 表示层：主要负责数据格式的转换，即翻译，压缩与解压缩，加密与解密。

      例如：你想下午两点出发去上海，你对上海的朋友说下午两点过来，朋友的理解却是你下午两点到上海，两个人两种理解，而表示层则是进行格式转换和信息的表示。

   7. 应用层：应用层是网络体系中最高的一层，也是唯一面向用户的一层，也可视为为用户提供常用的应用程序，例如电子邮件，上网浏览等网络服务都是应用层程序。

   ![微机原理2021-09-27-16-39-20](https://image.wxydejoy.top/img/微机原理2021-09-27-16-39-20.png!max)
   
4. 工业现场网络(RS485)物理层采用差分信号的益处

   标准的RS-232通讯接口仅支持两个设备之间连接，而且传输距离较短。由于差分信号具有极强的抗共模干扰的能力，而且信号的收发双方无需共地，因此差分传输被广泛应用于通讯领域， 譬如我们熟悉的USB通讯接口就是采用差分传输。

   严格说，电路中传输的所有电压信号都是差分的，以“系统地”作为基准电压来测量信号的电压，为了不引起混淆通常把此类信号称作单端的信号。 差分传输则使用一对信号线传输电压信号，使用两个信号的相对电压差值表示所传输的信号电压，在传输逻辑信号时“1”和“0”电压保持反转关系。有人把这一对信号线的状态比喻成跷跷板上的两个人A和B， 当A被翘起来时两人的高度差是正值(如代表逻辑“1”)，当B被翘起来时高度差为负值(如代表逻辑“0”)，任何时候在跷跷板的两边加上相同大小的力不会改变跷跷板的状态(即两人的高度差不会被改变)。 即使一对差分信号的电压差仅有数十个毫伏，外界干扰引起的几个伏特同时加在差分信号对上不会影响电压差，这就是差分信号的共模干扰抑制能力。

   为什么需要针对共模干扰呢？ 绝大多数干扰信号都是以共模形式存在。

5. 工业设备网络的应用层协议(ModBus等)

   Modbus协议的数据帧是什么样的结构呢？如图7.15所示。正常情况下，主机发送和从机应答的数据帧的结构如图7.15(a)，黑色色块的信息域是必须存在的，灰色色块的域则根据命令码确定是否存在。 从机接收到主机发送来的数据帧后根据帧结构和各信息域的约束条件侦测是否有误，如果发现错误则给出异常应答帧，如图7.15(b)。

   ![微机原理2021-09-27-16-24-32](https://image.wxydejoy.top/img/微机原理2021-09-27-16-24-32.png!max!max)

   Modbus协议的数据帧总是以从机地址字节为帧头，16位CRC校验字的低8位为帧尾，每个数据帧的第2个字节必须是命令码(或异常应答帧使用“0x80+命令码”)， 第3和4字节是寄存器的起始地址(有效值为0~9998)的高8位和低8位，第5和6字节是寄存器个数(或寄存器值)的高8位和低8位。此外，寄存器起始地址、寄存器个数和数据的字节数之间必须满足以下约束条件：

   寄存器起始地址的有效值为0~9998
   有效的寄存器个数为1～9999
   有效的寄存器起始地址与有效的寄存器个数之和不大于9999
   对于位(开关)操作类的命令码，数据的字节数必须等于寄存器个数除以8(向上圆整)
   对于字(寄存器)操作类的命令码，数据的字节数必须是寄存器个数的2倍

   Modbus协议要求从机根据上述的约束条件侦测数据帧是否有错误，如果发现错误则向主机发送异常应答帧(对应错误码是2、3、4)。 但是，如果从机发现CRC16校验失败则不必给主机任何应答。为什么发现CRC校验失败不必应答而违犯上述数值约束关系则需要发出异常应答？你觉得这样设计的原因有那些。

   请注意，上述的Modbus协议并不包含扩展的协议部分，如文件读写、诊断等扩展的协议。在Arduino开源平台使用任一开源板的异步串行通讯接口和Modbus协议即可与PLC通讯， 其中Arduino开源板是Modbus的主机，需要执行Modbus主机协议，在Arduino开源社区有很多种Modbus主机协议的开源项目可用，如 [3]_ 。 当然也可以使用Arduino开源板来模拟PLC，并执行Modbus从机协议，如开源项目 [4]_ ，从而实现两个Arduino开源板通过异步串行通讯接口执行Modbus协议进行通讯。

   除了Modbus协议之外，目前在用的串口通讯协议还有很多种，譬如PROFIBUS(PROcess FIeld BUS)、基金会现场总线FF(Foundation Fieldbus)、HostLink、 MECHATROLINK-II等，他们都可基于双绞线等物理层的RS-232、RS-422或RS-485接口，并使用MCU片上UART功能单元来实现的应用层协议。 

6. 面向位流编码的汽车控制网络(CAN总线)的消息优先级机制

   对照OSI模型，CAN总线规范仅包含物理层和数据链路层的标准。

   CAN总线具有以下几个特点：

   - 高可靠性。CAN总线采用无主的网络架构，网络传输不依赖于主机的可靠性。CAN总线采用消息ID和消息体的传输机制(无网络节点ID)，每个节点可发送或接收多个ID的消息，任何节点失效都不会影响其他节点和网络。
   - 低成本。CAN总线物理层采用低压差分信号，CAN总线物理层接口的收发器成本与RS485收发器相接近，但CAN总线收发器具有网络侦测能力(每个节点都可以检测自己发出的信号)。
   - 高传输效率。CAN总线使用面向位流编码的短数据帧，每个位都采用不归零编码，数据域最大长度位8字节。传输短数据帧时占用的网络周期短，受干扰或导致错误数据位的概率低，而且重传的时间也短。
   - 易组网。CAN总线采用消息ID(11位或29位两种长度的消息ID)的二进制‘0’位的多少分配消息传输优先级，允许多个节点自动竞争和仲裁获取总线的占用权，甚至支持即插即用的节点。
   - 开放协议和生态系统。CAN总线得到广泛应用的关键应归功于Bosch最初采用的开放版权策略，以及由半导体制造商(协议栈的硬件化)、汽车零部件开发商、软件开发商和行业协会等共同参与而打造的CAN总线生态。

   每个数据帧都包含帧起始域、仲裁域、控制域、数据域、CRC校验域、确认域、帧结束域和帧间隔域等。

   在CAN总线的规范中，将二进制位‘0’定义为“显性位”或“显性信号”、‘1’定义为“隐性位”或“隐性信号”。在传输显性位‘0’时，CAN_HI信号将被拉高到CAN总线收发器的工作电源电压VDD， 同时CAN_LO信号将被拉低到CAN总线收发器GND；传输隐性位‘1’时，CAN总线收发器不驱动CAN_HI和CAN_LO两个信号，即两个信号处于浮空状态，此时两总线信号受120欧姆终端匹配的影响都保持2V左右。

   ![2021-10-10-21-26-01](https://image.wxydejoy.top/image/微机原理/2021-10-10-21-26-01.png!max!/fh/300)

   假设某个CAN总线节点发出一个数据帧，其中帧ID=0x014且仅1个字节的数据0x01，这个完整的CAN总线数据帧由55个二进制位组成， 并结构化为8个信息域，其中绿色、黄色和红色背景的三个信息域分别是仲裁域(即信息ID)、控制域(指定信息域长度)和数据域(帧数据)， 按照我们的假设，这三个信息域的二进制位是确定的。此外，CRC校验域的内容是根据该域之前的位流内容计算得到15位长度的CRC值(循环冗余校验码)。 帧起始域、帧确认域、帧结束域和帧间隔域等都是固定的信息，即所有CAN2.0A数据帧的这些域都是相同的，这些固定内容的信息域用于同步CAN数据帧。

   CAN总线的物理层使用双绞线作为网络介质，两个信号分别称作CAN_HI和CAN_LO，他们组成一对差分信号，由CAN总线节点的物理层接口——总线收发器驱动。 CAN总线的数据帧是面向二进制位编码的结构化位流，每个数据帧都包含帧起始域、仲裁域、控制域、数据域、CRC校验域、确认域、帧结束域和帧间隔域等。

   CAN数据帧的11位帧/消息ID域和远程请求标志位组成仲裁域，有时候还把这个域称作优先级域，当然这些称呼都是名副其实的。与RS485总线组成的网络不同，CAN总线不对节点编址， 但要求CAN总线节点传输的数据帧/消息进行编址，即帧/消息ID，每个发送节点拥有一个或多个消息ID用于帧标示，接收者则根据需要接收或忽略网络上的消息。 原则上，CAN总线的消息发送者使用惟一ID发送消息。譬如汽车中控发出左后视镜和右后视镜的角度调整消息必需采用不同的ID，左右后视镜的控制器节点根据消息ID接收自己的指令， 忽略其他指令。

   CAN总线是一种多主(或无主)网络架构，任何节点都可以随时启动消息发送过程，但是发送者必须在发送消息ID期间侦测网络状态确保是否发送成功， 一旦发送不成功则停止发送过程，直到网络恢复空闲状态后再次启动发送过程。我们把CAN总线发送帧/消息ID和远程请求标志位的过程称作抢占总线的仲裁过程。如图8.2所示。

   ![微机原理2021-09-27-16-48-19](https://image.wxydejoy.top/img/微机原理2021-09-27-16-48-19.png!max!/fh/300)

   如前所述，发送隐性位‘1’时两个总线信号是浮空的，而发送显性位‘0’时两个总线信号受总线收发器直接驱动。这也就是说，如果两个CAN节点同时发送数据， 假设A节点发送‘0’、B节点发送‘1’，那么总线上实际传送的是‘0’，即隐性位‘1’被显性位‘0’覆盖。

   在图8.2所示的仲裁过程中，如果两个CAN节点同时启动数据帧传输， 起始域是显性位‘0’显然可以准确地传送，假设两个节点传输的消息ID不是完全相同的，譬如A节点正在传输的消息ID为‘b00000010100’(十六进制表示为0x014)， B节点正在传输的消息ID为‘b00000100100’(十六进制表示为0x024)，那么B节点传输到ID[6]的‘1’时将会失败，因为该隐性位‘1’被A节点的ID[6]位所覆盖， 此时B节点按照CAN总线的仲裁机制立即退出总线竞争，A节点将成功地将消息发送出去，一旦A节点发送完毕则立即释放总线，B节点侦测到总线空闲后则再次启动消息发送过程， 此时如果没有其他节点与B节点竞争总线则B节点也能成功地将消息发送出去。

   仲裁域的最后一个位(即远程请求标志位)会在什么情况下有仲裁作用呢？仅在ID域完全相同的情况下，这个位才会影响仲裁结果。很显然，ID域不相同的两个或多个节点之间的总线竞争和仲裁结果是确定的， 远程请求标志位将不会有作用。ID域完全相同的两个或多个节点对CAN总线的竞争只会发生在：一个或多个节点主动地同时向某个远程节点请求特定ID的消息时， 该远程节点也正好要发送此特定ID的消息。
   
   注意，远程请求帧的这个标志位是隐性的(即‘1’)，但标准的CAN数据帧的这个标志位是显性的(即‘0’)。 现在我们已经很清楚地知道，ID域完全相同的远程请求帧和数据帧之间的竞争和仲裁结果：发送数据帧的节点将赢得总线占用权。举一个简单例子， 某汽车温度控制节点(CAN节点)的消息ID固定为0x078，汽车中控台发出请求温度消息的远程请求帧，该远程请求帧的ID域为0x078且远程请求标志位为‘1’， 同时温度控制节点正好发送温度消息，该数据帧的ID域为0x078且远程请求标志位为‘0’，最终温度控制节点赢得总线占用权，中控台的远程请求帧未发送成功， 但是中控台仍接收到温度数据帧。
   
   现在看起来，使用CAN总线组网是非常容易的，尤其使用CAN总线传输系统应用层的数据信息几乎不消耗MCU的存储资源和CPU时间。但是，CAN总线并不是实时网络， 一个节点的消息被成功地发送和接收的时间是不确定的，尤其CAN总线上多个节点之间的数据传输非常频繁时，某些低优先级的消息可能会传输失败。 虽然RS485总线、ModBus等协议构建的主从网络采用主机轮询各从机的效率比较低，但借助于固定周期的从机轮询机制可以确保数据传输的实时性。 关于CAN总线的数据传输延迟，不同的CAN网络环境的总线竞争和仲裁周期、数据帧传输失败的概率等理论计算和实践验证请参考[3]的第4章。

   最后还需要了解CAN总线相关的另一个重要概念——位填充。位填充操作是由CAN协议控制器自动完成，CAN总线操作软件仅仅对CAN协议控制器做配置而已：是否启用位填充。 CAN总线数据帧的位填充指的是，待发送的位流如果出现连续5个同极性位时则插入一个相反极性的位。位填充操作可以确保接收者与发送者有足够多的跳变保持同步， 这是因为CAN总线采用不归零编码。位填充操作由发送者自动添加，并由接收者自动删除，CAN总线的应用层数据不受任何影响。CAN数据帧的位填充仅仅对帧起始域、 仲裁域、控制域、数据域和CRC校验域有作用。如果我们的软件配置CAN协议控制器启用位填充功能，当接收到连续6个或以上同极性位则视为总线发送错误， CAN协议控制器将发出总线错误信息。

7. 无线、有线宽带网络(WiFi、以太网等)及其互联协议(http和MQTT等)相关的基础概念和应用。





   

   

